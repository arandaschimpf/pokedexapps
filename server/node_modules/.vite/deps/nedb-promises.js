import {
  require_util
} from "./chunk-KIWL7QHT.js";
import {
  __commonJS,
  __require
} from "./chunk-TDUMLE5V.js";

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@seald-io/nedb/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@seald-io/nedb/lib/utils.js"(exports, module) {
    var uniq = (array, iteratee) => {
      if (iteratee)
        return [...new Map(array.map((x) => [iteratee(x), x])).values()];
      else
        return [...new Set(array)];
    };
    var isObject = (arg) => typeof arg === "object" && arg !== null;
    var isDate = (d) => isObject(d) && Object.prototype.toString.call(d) === "[object Date]";
    var isRegExp = (re) => isObject(re) && Object.prototype.toString.call(re) === "[object RegExp]";
    var pick = (object, keys) => {
      return keys.reduce((obj, key) => {
        if (object && Object.prototype.hasOwnProperty.call(object, key)) {
          obj[key] = object[key];
        }
        return obj;
      }, {});
    };
    var filterIndexNames = (indexNames) => ([k, v]) => !!(typeof v === "string" || typeof v === "number" || typeof v === "boolean" || isDate(v) || v === null) && indexNames.includes(k);
    module.exports.uniq = uniq;
    module.exports.isDate = isDate;
    module.exports.isRegExp = isRegExp;
    module.exports.pick = pick;
    module.exports.filterIndexNames = filterIndexNames;
  }
});

// node_modules/@seald-io/nedb/lib/model.js
var require_model = __commonJS({
  "node_modules/@seald-io/nedb/lib/model.js"(exports, module) {
    var { uniq, isDate, isRegExp } = require_utils();
    var checkKey = (k, v) => {
      if (typeof k === "number")
        k = k.toString();
      if (k[0] === "$" && !(k === "$$date" && typeof v === "number") && !(k === "$$deleted" && v === true) && !(k === "$$indexCreated") && !(k === "$$indexRemoved"))
        throw new Error("Field names cannot begin with the $ character");
      if (k.indexOf(".") !== -1)
        throw new Error("Field names cannot contain a .");
    };
    var checkObject = (obj) => {
      if (Array.isArray(obj)) {
        obj.forEach((o) => {
          checkObject(o);
        });
      }
      if (typeof obj === "object" && obj !== null) {
        for (const k in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, k)) {
            checkKey(k, obj[k]);
            checkObject(obj[k]);
          }
        }
      }
    };
    var serialize = (obj) => {
      return JSON.stringify(obj, function(k, v) {
        checkKey(k, v);
        if (v === void 0)
          return void 0;
        if (v === null)
          return null;
        if (typeof this[k].getTime === "function")
          return { $$date: this[k].getTime() };
        return v;
      });
    };
    var deserialize = (rawData) => JSON.parse(rawData, function(k, v) {
      if (k === "$$date")
        return new Date(v);
      if (typeof v === "string" || typeof v === "number" || typeof v === "boolean" || v === null)
        return v;
      if (v && v.$$date)
        return v.$$date;
      return v;
    });
    function deepCopy(obj, strictKeys) {
      if (typeof obj === "boolean" || typeof obj === "number" || typeof obj === "string" || obj === null || isDate(obj))
        return obj;
      if (Array.isArray(obj))
        return obj.map((o) => deepCopy(o, strictKeys));
      if (typeof obj === "object") {
        const res = {};
        for (const k in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, k) && (!strictKeys || k[0] !== "$" && k.indexOf(".") === -1)) {
            res[k] = deepCopy(obj[k], strictKeys);
          }
        }
        return res;
      }
      return void 0;
    }
    var isPrimitiveType = (obj) => typeof obj === "boolean" || typeof obj === "number" || typeof obj === "string" || obj === null || isDate(obj) || Array.isArray(obj);
    var compareNSB = (a, b) => {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    };
    var compareArrays = (a, b) => {
      const minLength = Math.min(a.length, b.length);
      for (let i = 0; i < minLength; i += 1) {
        const comp = compareThings(a[i], b[i]);
        if (comp !== 0)
          return comp;
      }
      return compareNSB(a.length, b.length);
    };
    var compareThings = (a, b, _compareStrings) => {
      const compareStrings = _compareStrings || compareNSB;
      if (a === void 0)
        return b === void 0 ? 0 : -1;
      if (b === void 0)
        return 1;
      if (a === null)
        return b === null ? 0 : -1;
      if (b === null)
        return 1;
      if (typeof a === "number")
        return typeof b === "number" ? compareNSB(a, b) : -1;
      if (typeof b === "number")
        return typeof a === "number" ? compareNSB(a, b) : 1;
      if (typeof a === "string")
        return typeof b === "string" ? compareStrings(a, b) : -1;
      if (typeof b === "string")
        return typeof a === "string" ? compareStrings(a, b) : 1;
      if (typeof a === "boolean")
        return typeof b === "boolean" ? compareNSB(a, b) : -1;
      if (typeof b === "boolean")
        return typeof a === "boolean" ? compareNSB(a, b) : 1;
      if (isDate(a))
        return isDate(b) ? compareNSB(a.getTime(), b.getTime()) : -1;
      if (isDate(b))
        return isDate(a) ? compareNSB(a.getTime(), b.getTime()) : 1;
      if (Array.isArray(a))
        return Array.isArray(b) ? compareArrays(a, b) : -1;
      if (Array.isArray(b))
        return Array.isArray(a) ? compareArrays(a, b) : 1;
      const aKeys = Object.keys(a).sort();
      const bKeys = Object.keys(b).sort();
      for (let i = 0; i < Math.min(aKeys.length, bKeys.length); i += 1) {
        const comp = compareThings(a[aKeys[i]], b[bKeys[i]]);
        if (comp !== 0)
          return comp;
      }
      return compareNSB(aKeys.length, bKeys.length);
    };
    var createModifierFunction = (lastStepModifierFunction, unset = false) => (obj, field, value) => {
      const func = (obj2, field2, value2) => {
        const fieldParts = typeof field2 === "string" ? field2.split(".") : field2;
        if (fieldParts.length === 1)
          lastStepModifierFunction(obj2, field2, value2);
        else {
          if (obj2[fieldParts[0]] === void 0) {
            if (unset)
              return;
            obj2[fieldParts[0]] = {};
          }
          func(obj2[fieldParts[0]], fieldParts.slice(1), value2);
        }
      };
      return func(obj, field, value);
    };
    var $addToSetPartial = (obj, field, value) => {
      if (!Object.prototype.hasOwnProperty.call(obj, field)) {
        obj[field] = [];
      }
      if (!Array.isArray(obj[field]))
        throw new Error("Can't $addToSet an element on non-array values");
      if (value !== null && typeof value === "object" && value.$each) {
        if (Object.keys(value).length > 1)
          throw new Error("Can't use another field in conjunction with $each");
        if (!Array.isArray(value.$each))
          throw new Error("$each requires an array value");
        value.$each.forEach((v) => {
          $addToSetPartial(obj, field, v);
        });
      } else {
        let addToSet = true;
        obj[field].forEach((v) => {
          if (compareThings(v, value) === 0)
            addToSet = false;
        });
        if (addToSet)
          obj[field].push(value);
      }
    };
    var modifierFunctions = {
      /**
       * Set a field to a new value
       */
      $set: createModifierFunction((obj, field, value) => {
        obj[field] = value;
      }),
      /**
       * Unset a field
       */
      $unset: createModifierFunction((obj, field, value) => {
        delete obj[field];
      }, true),
      /**
       * Updates the value of the field, only if specified field is smaller than the current value of the field
       */
      $min: createModifierFunction((obj, field, value) => {
        if (typeof obj[field] === "undefined")
          obj[field] = value;
        else if (value < obj[field])
          obj[field] = value;
      }),
      /**
       * Updates the value of the field, only if specified field is greater than the current value of the field
       */
      $max: createModifierFunction((obj, field, value) => {
        if (typeof obj[field] === "undefined")
          obj[field] = value;
        else if (value > obj[field])
          obj[field] = value;
      }),
      /**
       * Increment a numeric field's value
       */
      $inc: createModifierFunction((obj, field, value) => {
        if (typeof value !== "number")
          throw new Error(`${value} must be a number`);
        if (typeof obj[field] !== "number") {
          if (!Object.prototype.hasOwnProperty.call(obj, field))
            obj[field] = value;
          else
            throw new Error("Don't use the $inc modifier on non-number fields");
        } else
          obj[field] += value;
      }),
      /**
       * Removes all instances of a value from an existing array
       */
      $pull: createModifierFunction((obj, field, value) => {
        if (!Array.isArray(obj[field]))
          throw new Error("Can't $pull an element from non-array values");
        const arr = obj[field];
        for (let i = arr.length - 1; i >= 0; i -= 1) {
          if (match(arr[i], value))
            arr.splice(i, 1);
        }
      }),
      /**
       * Remove the first or last element of an array
       */
      $pop: createModifierFunction((obj, field, value) => {
        if (!Array.isArray(obj[field]))
          throw new Error("Can't $pop an element from non-array values");
        if (typeof value !== "number")
          throw new Error(`${value} isn't an integer, can't use it with $pop`);
        if (value === 0)
          return;
        if (value > 0)
          obj[field] = obj[field].slice(0, obj[field].length - 1);
        else
          obj[field] = obj[field].slice(1);
      }),
      /**
       * Add an element to an array field only if it is not already in it
       * No modification if the element is already in the array
       * Note that it doesn't check whether the original array contains duplicates
       */
      $addToSet: createModifierFunction($addToSetPartial),
      /**
       * Push an element to the end of an array field
       * Optional modifier $each instead of value to push several values
       * Optional modifier $slice to slice the resulting array, see https://docs.mongodb.org/manual/reference/operator/update/slice/
       * Difference with MongoDB: if $slice is specified and not $each, we act as if value is an empty array
       */
      $push: createModifierFunction((obj, field, value) => {
        if (!Object.prototype.hasOwnProperty.call(obj, field))
          obj[field] = [];
        if (!Array.isArray(obj[field]))
          throw new Error("Can't $push an element on non-array values");
        if (value !== null && typeof value === "object" && value.$slice && value.$each === void 0)
          value.$each = [];
        if (value !== null && typeof value === "object" && value.$each) {
          if (Object.keys(value).length >= 3 || Object.keys(value).length === 2 && value.$slice === void 0)
            throw new Error("Can only use $slice in cunjunction with $each when $push to array");
          if (!Array.isArray(value.$each))
            throw new Error("$each requires an array value");
          value.$each.forEach((v) => {
            obj[field].push(v);
          });
          if (value.$slice === void 0 || typeof value.$slice !== "number")
            return;
          if (value.$slice === 0)
            obj[field] = [];
          else {
            let start;
            let end;
            const n = obj[field].length;
            if (value.$slice < 0) {
              start = Math.max(0, n + value.$slice);
              end = n;
            } else if (value.$slice > 0) {
              start = 0;
              end = Math.min(n, value.$slice);
            }
            obj[field] = obj[field].slice(start, end);
          }
        } else {
          obj[field].push(value);
        }
      })
    };
    var modify = (obj, updateQuery) => {
      const keys = Object.keys(updateQuery);
      const firstChars = keys.map((item) => item[0]);
      const dollarFirstChars = firstChars.filter((c) => c === "$");
      let newDoc;
      let modifiers;
      if (keys.indexOf("_id") !== -1 && updateQuery._id !== obj._id)
        throw new Error("You cannot change a document's _id");
      if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length)
        throw new Error("You cannot mix modifiers and normal fields");
      if (dollarFirstChars.length === 0) {
        newDoc = deepCopy(updateQuery);
        newDoc._id = obj._id;
      } else {
        modifiers = uniq(keys);
        newDoc = deepCopy(obj);
        modifiers.forEach((m) => {
          if (!modifierFunctions[m])
            throw new Error(`Unknown modifier ${m}`);
          if (typeof updateQuery[m] !== "object")
            throw new Error(`Modifier ${m}'s argument must be an object`);
          const keys2 = Object.keys(updateQuery[m]);
          keys2.forEach((k) => {
            modifierFunctions[m](newDoc, k, updateQuery[m][k]);
          });
        });
      }
      checkObject(newDoc);
      if (obj._id !== newDoc._id)
        throw new Error("You can't change a document's _id");
      return newDoc;
    };
    var getDotValue = (obj, field) => {
      const fieldParts = typeof field === "string" ? field.split(".") : field;
      if (!obj)
        return void 0;
      if (fieldParts.length === 0)
        return obj;
      if (fieldParts.length === 1)
        return obj[fieldParts[0]];
      if (Array.isArray(obj[fieldParts[0]])) {
        const i = parseInt(fieldParts[1], 10);
        if (typeof i === "number" && !isNaN(i))
          return getDotValue(obj[fieldParts[0]][i], fieldParts.slice(2));
        return obj[fieldParts[0]].map((el) => getDotValue(el, fieldParts.slice(1)));
      } else
        return getDotValue(obj[fieldParts[0]], fieldParts.slice(1));
    };
    var getDotValues = (obj, fields) => {
      if (!Array.isArray(fields))
        throw new Error("fields must be an Array");
      if (fields.length > 1) {
        const key = {};
        for (const field of fields) {
          key[field] = getDotValue(obj, field);
        }
        return key;
      } else
        return getDotValue(obj, fields[0]);
    };
    var areThingsEqual = (a, b) => {
      if (a === null || typeof a === "string" || typeof a === "boolean" || typeof a === "number" || b === null || typeof b === "string" || typeof b === "boolean" || typeof b === "number")
        return a === b;
      if (isDate(a) || isDate(b))
        return isDate(a) && isDate(b) && a.getTime() === b.getTime();
      if (!(Array.isArray(a) && Array.isArray(b)) && (Array.isArray(a) || Array.isArray(b)) || a === void 0 || b === void 0)
        return false;
      let aKeys;
      let bKeys;
      try {
        aKeys = Object.keys(a);
        bKeys = Object.keys(b);
      } catch (e) {
        return false;
      }
      if (aKeys.length !== bKeys.length)
        return false;
      for (const el of aKeys) {
        if (bKeys.indexOf(el) === -1)
          return false;
        if (!areThingsEqual(a[el], b[el]))
          return false;
      }
      return true;
    };
    var areComparable = (a, b) => {
      if (typeof a !== "string" && typeof a !== "number" && !isDate(a) && typeof b !== "string" && typeof b !== "number" && !isDate(b))
        return false;
      if (typeof a !== typeof b)
        return false;
      return true;
    };
    var comparisonFunctions = {
      /** Lower than */
      $lt: (a, b) => areComparable(a, b) && a < b,
      /** Lower than or equals */
      $lte: (a, b) => areComparable(a, b) && a <= b,
      /** Greater than */
      $gt: (a, b) => areComparable(a, b) && a > b,
      /** Greater than or equals */
      $gte: (a, b) => areComparable(a, b) && a >= b,
      /** Does not equal */
      $ne: (a, b) => a === void 0 || !areThingsEqual(a, b),
      /** Is in Array */
      $in: (a, b) => {
        if (!Array.isArray(b))
          throw new Error("$in operator called with a non-array");
        for (const el of b) {
          if (areThingsEqual(a, el))
            return true;
        }
        return false;
      },
      /** Is not in Array */
      $nin: (a, b) => {
        if (!Array.isArray(b))
          throw new Error("$nin operator called with a non-array");
        return !comparisonFunctions.$in(a, b);
      },
      /** Matches Regexp */
      $regex: (a, b) => {
        if (!isRegExp(b))
          throw new Error("$regex operator called with non regular expression");
        if (typeof a !== "string")
          return false;
        else
          return b.test(a);
      },
      /** Returns true if field exists */
      $exists: (a, b) => {
        if (b || b === "")
          b = true;
        else
          b = false;
        if (a === void 0)
          return !b;
        else
          return b;
      },
      /** Specific to Arrays, returns true if a length equals b */
      $size: (a, b) => {
        if (!Array.isArray(a))
          return false;
        if (b % 1 !== 0)
          throw new Error("$size operator called without an integer");
        return a.length === b;
      },
      /** Specific to Arrays, returns true if some elements of a match the query b */
      $elemMatch: (a, b) => {
        if (!Array.isArray(a))
          return false;
        return a.some((el) => match(el, b));
      }
    };
    var arrayComparisonFunctions = { $size: true, $elemMatch: true };
    var logicalOperators = {
      /**
       * Match any of the subqueries
       * @param {document} obj
       * @param {query[]} query
       * @return {boolean}
       */
      $or: (obj, query) => {
        if (!Array.isArray(query))
          throw new Error("$or operator used without an array");
        for (let i = 0; i < query.length; i += 1) {
          if (match(obj, query[i]))
            return true;
        }
        return false;
      },
      /**
       * Match all of the subqueries
       * @param {document} obj
       * @param {query[]} query
       * @return {boolean}
       */
      $and: (obj, query) => {
        if (!Array.isArray(query))
          throw new Error("$and operator used without an array");
        for (let i = 0; i < query.length; i += 1) {
          if (!match(obj, query[i]))
            return false;
        }
        return true;
      },
      /**
       * Inverted match of the query
       * @param {document} obj
       * @param {query} query
       * @return {boolean}
       */
      $not: (obj, query) => !match(obj, query),
      /**
       * @callback whereCallback
       * @param {document} obj
       * @return {boolean}
       */
      /**
       * Use a function to match
       * @param {document} obj
       * @param {whereCallback} fn
       * @return {boolean}
       */
      $where: (obj, fn) => {
        if (typeof fn !== "function")
          throw new Error("$where operator used without a function");
        const result = fn.call(obj);
        if (typeof result !== "boolean")
          throw new Error("$where function must return boolean");
        return result;
      }
    };
    var match = (obj, query) => {
      if (isPrimitiveType(obj) || isPrimitiveType(query))
        return matchQueryPart({ needAKey: obj }, "needAKey", query);
      for (const queryKey in query) {
        if (Object.prototype.hasOwnProperty.call(query, queryKey)) {
          const queryValue = query[queryKey];
          if (queryKey[0] === "$") {
            if (!logicalOperators[queryKey])
              throw new Error(`Unknown logical operator ${queryKey}`);
            if (!logicalOperators[queryKey](obj, queryValue))
              return false;
          } else if (!matchQueryPart(obj, queryKey, queryValue))
            return false;
        }
      }
      return true;
    };
    function matchQueryPart(obj, queryKey, queryValue, treatObjAsValue) {
      const objValue = getDotValue(obj, queryKey);
      if (Array.isArray(objValue) && !treatObjAsValue) {
        if (Array.isArray(queryValue))
          return matchQueryPart(obj, queryKey, queryValue, true);
        if (queryValue !== null && typeof queryValue === "object" && !isRegExp(queryValue)) {
          for (const key in queryValue) {
            if (Object.prototype.hasOwnProperty.call(queryValue, key) && arrayComparisonFunctions[key]) {
              return matchQueryPart(obj, queryKey, queryValue, true);
            }
          }
        }
        for (const el of objValue) {
          if (matchQueryPart({ k: el }, "k", queryValue))
            return true;
        }
        return false;
      }
      if (queryValue !== null && typeof queryValue === "object" && !isRegExp(queryValue) && !Array.isArray(queryValue)) {
        const keys = Object.keys(queryValue);
        const firstChars = keys.map((item) => item[0]);
        const dollarFirstChars = firstChars.filter((c) => c === "$");
        if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length)
          throw new Error("You cannot mix operators and normal fields");
        if (dollarFirstChars.length > 0) {
          for (const key of keys) {
            if (!comparisonFunctions[key])
              throw new Error(`Unknown comparison function ${key}`);
            if (!comparisonFunctions[key](objValue, queryValue[key]))
              return false;
          }
          return true;
        }
      }
      if (isRegExp(queryValue))
        return comparisonFunctions.$regex(objValue, queryValue);
      return areThingsEqual(objValue, queryValue);
    }
    module.exports.serialize = serialize;
    module.exports.deserialize = deserialize;
    module.exports.deepCopy = deepCopy;
    module.exports.checkObject = checkObject;
    module.exports.isPrimitiveType = isPrimitiveType;
    module.exports.modify = modify;
    module.exports.getDotValue = getDotValue;
    module.exports.getDotValues = getDotValues;
    module.exports.match = match;
    module.exports.areThingsEqual = areThingsEqual;
    module.exports.compareThings = compareThings;
  }
});

// node_modules/@seald-io/nedb/lib/cursor.js
var require_cursor = __commonJS({
  "node_modules/@seald-io/nedb/lib/cursor.js"(exports, module) {
    var model = require_model();
    var { callbackify } = require_util();
    var Cursor = class {
      /**
       * Create a new cursor for this collection.
       * @param {Datastore} db - The datastore this cursor is bound to
       * @param {query} query - The query this cursor will operate on
       * @param {Cursor~mapFn} [mapFn] - Handler to be executed after cursor has found the results and before the callback passed to find/findOne/update/remove
       */
      constructor(db, query, mapFn) {
        this.db = db;
        this.query = query || {};
        if (mapFn)
          this.mapFn = mapFn;
        this._limit = void 0;
        this._skip = void 0;
        this._sort = void 0;
        this._projection = void 0;
      }
      /**
       * Set a limit to the number of results for the given Cursor.
       * @param {Number} limit
       * @return {Cursor} the same instance of Cursor, (useful for chaining).
       */
      limit(limit) {
        this._limit = limit;
        return this;
      }
      /**
       * Skip a number of results for the given Cursor.
       * @param {Number} skip
       * @return {Cursor} the same instance of Cursor, (useful for chaining).
       */
      skip(skip) {
        this._skip = skip;
        return this;
      }
      /**
       * Sort results of the query for the given Cursor.
       * @param {Object.<string, number>} sortQuery - sortQuery is { field: order }, field can use the dot-notation, order is 1 for ascending and -1 for descending
       * @return {Cursor} the same instance of Cursor, (useful for chaining).
       */
      sort(sortQuery) {
        this._sort = sortQuery;
        return this;
      }
      /**
       * Add the use of a projection to the given Cursor.
       * @param {Object.<string, number>} projection - MongoDB-style projection. {} means take all fields. Then it's { key1: 1, key2: 1 } to take only key1 and key2
       * { key1: 0, key2: 0 } to omit only key1 and key2. Except _id, you can't mix takes and omits.
       * @return {Cursor} the same instance of Cursor, (useful for chaining).
       */
      projection(projection) {
        this._projection = projection;
        return this;
      }
      /**
       * Apply the projection.
       *
       * This is an internal function. You should use {@link Cursor#execAsync} or {@link Cursor#exec}.
       * @param {document[]} candidates
       * @return {document[]}
       * @private
       */
      _project(candidates) {
        const res = [];
        let action;
        if (this._projection === void 0 || Object.keys(this._projection).length === 0) {
          return candidates;
        }
        const keepId = this._projection._id !== 0;
        const { _id, ...rest } = this._projection;
        this._projection = rest;
        const keys = Object.keys(this._projection);
        keys.forEach((k) => {
          if (action !== void 0 && this._projection[k] !== action)
            throw new Error("Can't both keep and omit fields except for _id");
          action = this._projection[k];
        });
        candidates.forEach((candidate) => {
          let toPush;
          if (action === 1) {
            toPush = { $set: {} };
            keys.forEach((k) => {
              toPush.$set[k] = model.getDotValue(candidate, k);
              if (toPush.$set[k] === void 0)
                delete toPush.$set[k];
            });
            toPush = model.modify({}, toPush);
          } else {
            toPush = { $unset: {} };
            keys.forEach((k) => {
              toPush.$unset[k] = true;
            });
            toPush = model.modify(candidate, toPush);
          }
          if (keepId)
            toPush._id = candidate._id;
          else
            delete toPush._id;
          res.push(toPush);
        });
        return res;
      }
      /**
       * Get all matching elements
       * Will return pointers to matched elements (shallow copies), returning full copies is the role of find or findOne
       * This is an internal function, use execAsync which uses the executor
       * @return {document[]|Promise<*>}
       * @private
       */
      async _execAsync() {
        let res = [];
        let added = 0;
        let skipped = 0;
        const candidates = await this.db._getCandidatesAsync(this.query);
        for (const candidate of candidates) {
          if (model.match(candidate, this.query)) {
            if (!this._sort) {
              if (this._skip && this._skip > skipped)
                skipped += 1;
              else {
                res.push(candidate);
                added += 1;
                if (this._limit && this._limit <= added)
                  break;
              }
            } else
              res.push(candidate);
          }
        }
        if (this._sort) {
          const criteria = Object.entries(this._sort).map(([key, direction]) => ({ key, direction }));
          res.sort((a, b) => {
            for (const criterion of criteria) {
              const compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion.key), this.db.compareStrings);
              if (compare !== 0)
                return compare;
            }
            return 0;
          });
          const limit = this._limit || res.length;
          const skip = this._skip || 0;
          res = res.slice(skip, skip + limit);
        }
        res = this._project(res);
        if (this.mapFn)
          return this.mapFn(res);
        return res;
      }
      /**
       * @callback Cursor~execCallback
       * @param {Error} err
       * @param {document[]|*} res If a mapFn was given to the Cursor, then the type of this parameter is the one returned by the mapFn.
       */
      /**
       * Callback version of {@link Cursor#exec}.
       * @param {Cursor~execCallback} _callback
       * @see Cursor#execAsync
       */
      exec(_callback) {
        callbackify(() => this.execAsync())(_callback);
      }
      /**
       * Get all matching elements.
       * Will return pointers to matched elements (shallow copies), returning full copies is the role of {@link Datastore#findAsync} or {@link Datastore#findOneAsync}.
       * @return {Promise<document[]|*>}
       * @async
       */
      execAsync() {
        return this.db.executor.pushAsync(() => this._execAsync());
      }
      then(onFulfilled, onRejected) {
        return this.execAsync().then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this.execAsync().catch(onRejected);
      }
      finally(onFinally) {
        return this.execAsync().finally(onFinally);
      }
    };
    module.exports = Cursor;
  }
});

// node_modules/@seald-io/nedb/browser-version/lib/customUtils.js
var require_customUtils = __commonJS({
  "node_modules/@seald-io/nedb/browser-version/lib/customUtils.js"(exports, module) {
    var randomBytes = (size) => {
      const bytes = new Array(size);
      for (let i = 0, r; i < size; i++) {
        if ((i & 3) === 0)
          r = Math.random() * 4294967296;
        bytes[i] = r >>> ((i & 3) << 3) & 255;
      }
      return bytes;
    };
    var byteArrayToBase64 = (uint8) => {
      const lookup = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const extraBytes = uint8.length % 3;
      let output = "";
      let temp;
      const tripletToBase64 = (num) => lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      for (let i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
        output += tripletToBase64(temp);
      }
      if (extraBytes === 1) {
        temp = uint8[uint8.length - 1];
        output += lookup[temp >> 2];
        output += lookup[temp << 4 & 63];
        output += "==";
      } else if (extraBytes === 2) {
        temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
        output += lookup[temp >> 10];
        output += lookup[temp >> 4 & 63];
        output += lookup[temp << 2 & 63];
        output += "=";
      }
      return output;
    };
    var uid = (len) => byteArrayToBase64(randomBytes(Math.ceil(Math.max(8, len * 2)))).replace(/[+/]/g, "").slice(0, len);
    module.exports.uid = uid;
  }
});

// node_modules/@seald-io/nedb/lib/waterfall.js
var require_waterfall = __commonJS({
  "node_modules/@seald-io/nedb/lib/waterfall.js"(exports, module) {
    var Waterfall = class {
      /**
       * Instantiate a new Waterfall.
       */
      constructor() {
        this.guardian = Promise.resolve();
      }
      /**
       *
       * @param {AsyncFunction} func
       * @return {AsyncFunction}
       */
      waterfall(func) {
        return (...args) => {
          this.guardian = this.guardian.then(() => {
            return func(...args).then((result) => ({ error: false, result }), (result) => ({ error: true, result }));
          });
          return this.guardian.then(({ error, result }) => {
            if (error)
              return Promise.reject(result);
            else
              return Promise.resolve(result);
          });
        };
      }
      /**
       * Shorthand for chaining a promise to the Waterfall
       * @param {Promise} promise
       * @return {Promise}
       */
      chain(promise) {
        return this.waterfall(() => promise)();
      }
    };
    module.exports = Waterfall;
  }
});

// node_modules/@seald-io/nedb/lib/executor.js
var require_executor = __commonJS({
  "node_modules/@seald-io/nedb/lib/executor.js"(exports, module) {
    var Waterfall = require_waterfall();
    var Executor = class {
      /**
       * Instantiates a new Executor.
       */
      constructor() {
        this.ready = false;
        this.queue = new Waterfall();
        this.buffer = null;
        this._triggerBuffer = null;
        this.resetBuffer();
      }
      /**
       * If executor is ready, queue task (and process it immediately if executor was idle)
       * If not, buffer task for later processing
       * @param {AsyncFunction} task Function to execute
       * @param {boolean} [forceQueuing = false] Optional (defaults to false) force executor to queue task even if it is not ready
       * @return {Promise<*>}
       * @async
       * @see Executor#push
       */
      pushAsync(task, forceQueuing = false) {
        if (this.ready || forceQueuing)
          return this.queue.waterfall(task)();
        else
          return this.buffer.waterfall(task)();
      }
      /**
       * Queue all tasks in buffer (in the same order they came in)
       * Automatically sets executor as ready
       */
      processBuffer() {
        this.ready = true;
        this._triggerBuffer();
        this.queue.waterfall(() => this.buffer.guardian);
      }
      /**
       * Removes all tasks queued up in the buffer
       */
      resetBuffer() {
        this.buffer = new Waterfall();
        this.buffer.chain(new Promise((resolve) => {
          this._triggerBuffer = resolve;
        }));
        if (this.ready)
          this._triggerBuffer();
      }
    };
    module.exports = Executor;
  }
});

// node_modules/@seald-io/binary-search-tree/lib/customUtils.js
var require_customUtils2 = __commonJS({
  "node_modules/@seald-io/binary-search-tree/lib/customUtils.js"(exports, module) {
    var getRandomArray = (n) => {
      if (n === 0)
        return [];
      if (n === 1)
        return [0];
      const res = getRandomArray(n - 1);
      const next = Math.floor(Math.random() * n);
      res.splice(next, 0, n - 1);
      return res;
    };
    module.exports.getRandomArray = getRandomArray;
    var defaultCompareKeysFunction = (a, b) => {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      if (a === b)
        return 0;
      const err = new Error("Couldn't compare elements");
      err.a = a;
      err.b = b;
      throw err;
    };
    module.exports.defaultCompareKeysFunction = defaultCompareKeysFunction;
    var defaultCheckValueEquality = (a, b) => a === b;
    module.exports.defaultCheckValueEquality = defaultCheckValueEquality;
  }
});

// node_modules/@seald-io/binary-search-tree/lib/bst.js
var require_bst = __commonJS({
  "node_modules/@seald-io/binary-search-tree/lib/bst.js"(exports, module) {
    var customUtils = require_customUtils2();
    var BinarySearchTree = class {
      /**
       * Constructor
       * @param {Object} options Optional
       * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not
       * @param {Key}      options.key Initialize this BST's key with key
       * @param {Value}    options.value Initialize this BST's data with [value]
       * @param {Function} options.compareKeys Initialize this BST's compareKeys
       */
      constructor(options) {
        options = options || {};
        this.left = null;
        this.right = null;
        this.parent = options.parent !== void 0 ? options.parent : null;
        if (Object.prototype.hasOwnProperty.call(options, "key")) {
          this.key = options.key;
        }
        this.data = Object.prototype.hasOwnProperty.call(options, "value") ? [options.value] : [];
        this.unique = options.unique || false;
        this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;
        this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;
      }
      /**
       * Get the descendant with max key
       */
      getMaxKeyDescendant() {
        if (this.right)
          return this.right.getMaxKeyDescendant();
        else
          return this;
      }
      /**
       * Get the maximum key
       */
      getMaxKey() {
        return this.getMaxKeyDescendant().key;
      }
      /**
       * Get the descendant with min key
       */
      getMinKeyDescendant() {
        if (this.left)
          return this.left.getMinKeyDescendant();
        else
          return this;
      }
      /**
       * Get the minimum key
       */
      getMinKey() {
        return this.getMinKeyDescendant().key;
      }
      /**
       * Check that all nodes (incl. leaves) fullfil condition given by fn
       * test is a function passed every (key, data) and which throws if the condition is not met
       */
      checkAllNodesFullfillCondition(test) {
        if (!Object.prototype.hasOwnProperty.call(this, "key"))
          return;
        test(this.key, this.data);
        if (this.left)
          this.left.checkAllNodesFullfillCondition(test);
        if (this.right)
          this.right.checkAllNodesFullfillCondition(test);
      }
      /**
       * Check that the core BST properties on node ordering are verified
       * Throw if they aren't
       */
      checkNodeOrdering() {
        if (!Object.prototype.hasOwnProperty.call(this, "key"))
          return;
        if (this.left) {
          this.left.checkAllNodesFullfillCondition((k) => {
            if (this.compareKeys(k, this.key) >= 0)
              throw new Error(`Tree with root ${this.key} is not a binary search tree`);
          });
          this.left.checkNodeOrdering();
        }
        if (this.right) {
          this.right.checkAllNodesFullfillCondition((k) => {
            if (this.compareKeys(k, this.key) <= 0)
              throw new Error(`Tree with root ${this.key} is not a binary search tree`);
          });
          this.right.checkNodeOrdering();
        }
      }
      /**
       * Check that all pointers are coherent in this tree
       */
      checkInternalPointers() {
        if (this.left) {
          if (this.left.parent !== this)
            throw new Error(`Parent pointer broken for key ${this.key}`);
          this.left.checkInternalPointers();
        }
        if (this.right) {
          if (this.right.parent !== this)
            throw new Error(`Parent pointer broken for key ${this.key}`);
          this.right.checkInternalPointers();
        }
      }
      /**
       * Check that a tree is a BST as defined here (node ordering and pointer references)
       */
      checkIsBST() {
        this.checkNodeOrdering();
        this.checkInternalPointers();
        if (this.parent)
          throw new Error("The root shouldn't have a parent");
      }
      /**
       * Get number of keys inserted
       */
      getNumberOfKeys() {
        let res;
        if (!Object.prototype.hasOwnProperty.call(this, "key"))
          return 0;
        res = 1;
        if (this.left)
          res += this.left.getNumberOfKeys();
        if (this.right)
          res += this.right.getNumberOfKeys();
        return res;
      }
      /**
       * Create a BST similar (i.e. same options except for key and value) to the current one
       * Use the same constructor (i.e. BinarySearchTree, AVLTree etc)
       * @param {Object} options see constructor
       */
      createSimilar(options) {
        options = options || {};
        options.unique = this.unique;
        options.compareKeys = this.compareKeys;
        options.checkValueEquality = this.checkValueEquality;
        return new this.constructor(options);
      }
      /**
       * Create the left child of this BST and return it
       */
      createLeftChild(options) {
        const leftChild = this.createSimilar(options);
        leftChild.parent = this;
        this.left = leftChild;
        return leftChild;
      }
      /**
       * Create the right child of this BST and return it
       */
      createRightChild(options) {
        const rightChild = this.createSimilar(options);
        rightChild.parent = this;
        this.right = rightChild;
        return rightChild;
      }
      /**
       * Insert a new element
       */
      insert(key, value) {
        if (!Object.prototype.hasOwnProperty.call(this, "key")) {
          this.key = key;
          this.data.push(value);
          return;
        }
        if (this.compareKeys(this.key, key) === 0) {
          if (this.unique) {
            const err = new Error(`Can't insert key ${JSON.stringify(key)}, it violates the unique constraint`);
            err.key = key;
            err.errorType = "uniqueViolated";
            throw err;
          } else
            this.data.push(value);
          return;
        }
        if (this.compareKeys(key, this.key) < 0) {
          if (this.left)
            this.left.insert(key, value);
          else
            this.createLeftChild({ key, value });
        } else {
          if (this.right)
            this.right.insert(key, value);
          else
            this.createRightChild({ key, value });
        }
      }
      /**
       * Search for all data corresponding to a key
       */
      search(key) {
        if (!Object.prototype.hasOwnProperty.call(this, "key"))
          return [];
        if (this.compareKeys(this.key, key) === 0)
          return this.data;
        if (this.compareKeys(key, this.key) < 0) {
          if (this.left)
            return this.left.search(key);
          else
            return [];
        } else {
          if (this.right)
            return this.right.search(key);
          else
            return [];
        }
      }
      /**
       * Return a function that tells whether a given key matches a lower bound
       */
      getLowerBoundMatcher(query) {
        if (!Object.prototype.hasOwnProperty.call(query, "$gt") && !Object.prototype.hasOwnProperty.call(query, "$gte"))
          return () => true;
        if (Object.prototype.hasOwnProperty.call(query, "$gt") && Object.prototype.hasOwnProperty.call(query, "$gte")) {
          if (this.compareKeys(query.$gte, query.$gt) === 0)
            return (key) => this.compareKeys(key, query.$gt) > 0;
          if (this.compareKeys(query.$gte, query.$gt) > 0)
            return (key) => this.compareKeys(key, query.$gte) >= 0;
          else
            return (key) => this.compareKeys(key, query.$gt) > 0;
        }
        if (Object.prototype.hasOwnProperty.call(query, "$gt"))
          return (key) => this.compareKeys(key, query.$gt) > 0;
        else
          return (key) => this.compareKeys(key, query.$gte) >= 0;
      }
      /**
       * Return a function that tells whether a given key matches an upper bound
       */
      getUpperBoundMatcher(query) {
        if (!Object.prototype.hasOwnProperty.call(query, "$lt") && !Object.prototype.hasOwnProperty.call(query, "$lte"))
          return () => true;
        if (Object.prototype.hasOwnProperty.call(query, "$lt") && Object.prototype.hasOwnProperty.call(query, "$lte")) {
          if (this.compareKeys(query.$lte, query.$lt) === 0)
            return (key) => this.compareKeys(key, query.$lt) < 0;
          if (this.compareKeys(query.$lte, query.$lt) < 0)
            return (key) => this.compareKeys(key, query.$lte) <= 0;
          else
            return (key) => this.compareKeys(key, query.$lt) < 0;
        }
        if (Object.prototype.hasOwnProperty.call(query, "$lt"))
          return (key) => this.compareKeys(key, query.$lt) < 0;
        else
          return (key) => this.compareKeys(key, query.$lte) <= 0;
      }
      /**
       * Get all data for a key between bounds
       * Return it in key order
       * @param {Object} query Mongo-style query where keys are $lt, $lte, $gt or $gte (other keys are not considered)
       * @param {Functions} lbm/ubm matching functions calculated at the first recursive step
       */
      betweenBounds(query, lbm, ubm) {
        const res = [];
        if (!Object.prototype.hasOwnProperty.call(this, "key"))
          return [];
        lbm = lbm || this.getLowerBoundMatcher(query);
        ubm = ubm || this.getUpperBoundMatcher(query);
        if (lbm(this.key) && this.left)
          append(res, this.left.betweenBounds(query, lbm, ubm));
        if (lbm(this.key) && ubm(this.key))
          append(res, this.data);
        if (ubm(this.key) && this.right)
          append(res, this.right.betweenBounds(query, lbm, ubm));
        return res;
      }
      /**
       * Delete the current node if it is a leaf
       * Return true if it was deleted
       */
      deleteIfLeaf() {
        if (this.left || this.right)
          return false;
        if (!this.parent) {
          delete this.key;
          this.data = [];
          return true;
        }
        if (this.parent.left === this)
          this.parent.left = null;
        else
          this.parent.right = null;
        return true;
      }
      /**
       * Delete the current node if it has only one child
       * Return true if it was deleted
       */
      deleteIfOnlyOneChild() {
        let child;
        if (this.left && !this.right)
          child = this.left;
        if (!this.left && this.right)
          child = this.right;
        if (!child)
          return false;
        if (!this.parent) {
          this.key = child.key;
          this.data = child.data;
          this.left = null;
          if (child.left) {
            this.left = child.left;
            child.left.parent = this;
          }
          this.right = null;
          if (child.right) {
            this.right = child.right;
            child.right.parent = this;
          }
          return true;
        }
        if (this.parent.left === this) {
          this.parent.left = child;
          child.parent = this.parent;
        } else {
          this.parent.right = child;
          child.parent = this.parent;
        }
        return true;
      }
      /**
       * Delete a key or just a value
       * @param {Key} key
       * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted
       */
      delete(key, value) {
        const newData = [];
        let replaceWith;
        if (!Object.prototype.hasOwnProperty.call(this, "key"))
          return;
        if (this.compareKeys(key, this.key) < 0) {
          if (this.left)
            this.left.delete(key, value);
          return;
        }
        if (this.compareKeys(key, this.key) > 0) {
          if (this.right)
            this.right.delete(key, value);
          return;
        }
        if (!this.compareKeys(key, this.key) === 0)
          return;
        if (this.data.length > 1 && value !== void 0) {
          this.data.forEach((d) => {
            if (!this.checkValueEquality(d, value))
              newData.push(d);
          });
          this.data = newData;
          return;
        }
        if (this.deleteIfLeaf())
          return;
        if (this.deleteIfOnlyOneChild())
          return;
        if (Math.random() >= 0.5) {
          replaceWith = this.left.getMaxKeyDescendant();
          this.key = replaceWith.key;
          this.data = replaceWith.data;
          if (this === replaceWith.parent) {
            this.left = replaceWith.left;
            if (replaceWith.left)
              replaceWith.left.parent = replaceWith.parent;
          } else {
            replaceWith.parent.right = replaceWith.left;
            if (replaceWith.left)
              replaceWith.left.parent = replaceWith.parent;
          }
        } else {
          replaceWith = this.right.getMinKeyDescendant();
          this.key = replaceWith.key;
          this.data = replaceWith.data;
          if (this === replaceWith.parent) {
            this.right = replaceWith.right;
            if (replaceWith.right)
              replaceWith.right.parent = replaceWith.parent;
          } else {
            replaceWith.parent.left = replaceWith.right;
            if (replaceWith.right)
              replaceWith.right.parent = replaceWith.parent;
          }
        }
      }
      /**
       * Execute a function on every node of the tree, in key order
       * @param {Function} fn Signature: node. Most useful will probably be node.key and node.data
       */
      executeOnEveryNode(fn) {
        if (this.left)
          this.left.executeOnEveryNode(fn);
        fn(this);
        if (this.right)
          this.right.executeOnEveryNode(fn);
      }
      /**
       * Pretty print a tree
       * @param {Boolean} printData To print the nodes' data along with the key
       */
      prettyPrint(printData, spacing) {
        spacing = spacing || "";
        console.log(`${spacing}* ${this.key}`);
        if (printData)
          console.log(`${spacing}* ${this.data}`);
        if (!this.left && !this.right)
          return;
        if (this.left)
          this.left.prettyPrint(printData, `${spacing}  `);
        else
          console.log(`${spacing}  *`);
        if (this.right)
          this.right.prettyPrint(printData, `${spacing}  `);
        else
          console.log(`${spacing}  *`);
      }
    };
    function append(array, toAppend) {
      for (let i = 0; i < toAppend.length; i += 1) {
        array.push(toAppend[i]);
      }
    }
    module.exports = BinarySearchTree;
  }
});

// node_modules/@seald-io/binary-search-tree/lib/avltree.js
var require_avltree = __commonJS({
  "node_modules/@seald-io/binary-search-tree/lib/avltree.js"(exports, module) {
    var BinarySearchTree = require_bst();
    var customUtils = require_customUtils2();
    var AVLTree = class {
      /**
       * Constructor
       * We can't use a direct pointer to the root node (as in the simple binary search tree)
       * as the root will change during tree rotations
       * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not
       * @param {Function} options.compareKeys Initialize this BST's compareKeys
       */
      constructor(options) {
        this.tree = new _AVLTree(options);
      }
      checkIsAVLT() {
        this.tree.checkIsAVLT();
      }
      // Insert in the internal tree, update the pointer to the root if needed
      insert(key, value) {
        const newTree = this.tree.insert(key, value);
        if (newTree) {
          this.tree = newTree;
        }
      }
      // Delete a value
      delete(key, value) {
        const newTree = this.tree.delete(key, value);
        if (newTree) {
          this.tree = newTree;
        }
      }
    };
    var _AVLTree = class extends BinarySearchTree {
      /**
       * Constructor of the internal AVLTree
       * @param {Object} options Optional
       * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not
       * @param {Key}      options.key Initialize this BST's key with key
       * @param {Value}    options.value Initialize this BST's data with [value]
       * @param {Function} options.compareKeys Initialize this BST's compareKeys
       */
      constructor(options) {
        super();
        options = options || {};
        this.left = null;
        this.right = null;
        this.parent = options.parent !== void 0 ? options.parent : null;
        if (Object.prototype.hasOwnProperty.call(options, "key"))
          this.key = options.key;
        this.data = Object.prototype.hasOwnProperty.call(options, "value") ? [options.value] : [];
        this.unique = options.unique || false;
        this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;
        this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;
      }
      /**
       * Check the recorded height is correct for every node
       * Throws if one height doesn't match
       */
      checkHeightCorrect() {
        if (!Object.prototype.hasOwnProperty.call(this, "key")) {
          return;
        }
        if (this.left && this.left.height === void 0) {
          throw new Error("Undefined height for node " + this.left.key);
        }
        if (this.right && this.right.height === void 0) {
          throw new Error("Undefined height for node " + this.right.key);
        }
        if (this.height === void 0) {
          throw new Error("Undefined height for node " + this.key);
        }
        const leftH = this.left ? this.left.height : 0;
        const rightH = this.right ? this.right.height : 0;
        if (this.height !== 1 + Math.max(leftH, rightH)) {
          throw new Error("Height constraint failed for node " + this.key);
        }
        if (this.left) {
          this.left.checkHeightCorrect();
        }
        if (this.right) {
          this.right.checkHeightCorrect();
        }
      }
      /**
       * Return the balance factor
       */
      balanceFactor() {
        const leftH = this.left ? this.left.height : 0;
        const rightH = this.right ? this.right.height : 0;
        return leftH - rightH;
      }
      /**
       * Check that the balance factors are all between -1 and 1
       */
      checkBalanceFactors() {
        if (Math.abs(this.balanceFactor()) > 1) {
          throw new Error("Tree is unbalanced at node " + this.key);
        }
        if (this.left) {
          this.left.checkBalanceFactors();
        }
        if (this.right) {
          this.right.checkBalanceFactors();
        }
      }
      /**
       * When checking if the BST conditions are met, also check that the heights are correct
       * and the tree is balanced
       */
      checkIsAVLT() {
        super.checkIsBST();
        this.checkHeightCorrect();
        this.checkBalanceFactors();
      }
      /**
       * Perform a right rotation of the tree if possible
       * and return the root of the resulting tree
       * The resulting tree's nodes' heights are also updated
       */
      rightRotation() {
        const q = this;
        const p = this.left;
        if (!p)
          return q;
        const b = p.right;
        if (q.parent) {
          p.parent = q.parent;
          if (q.parent.left === q)
            q.parent.left = p;
          else
            q.parent.right = p;
        } else {
          p.parent = null;
        }
        p.right = q;
        q.parent = p;
        q.left = b;
        if (b) {
          b.parent = q;
        }
        const ah = p.left ? p.left.height : 0;
        const bh = b ? b.height : 0;
        const ch = q.right ? q.right.height : 0;
        q.height = Math.max(bh, ch) + 1;
        p.height = Math.max(ah, q.height) + 1;
        return p;
      }
      /**
       * Perform a left rotation of the tree if possible
       * and return the root of the resulting tree
       * The resulting tree's nodes' heights are also updated
       */
      leftRotation() {
        const p = this;
        const q = this.right;
        if (!q) {
          return this;
        }
        const b = q.left;
        if (p.parent) {
          q.parent = p.parent;
          if (p.parent.left === p)
            p.parent.left = q;
          else
            p.parent.right = q;
        } else {
          q.parent = null;
        }
        q.left = p;
        p.parent = q;
        p.right = b;
        if (b) {
          b.parent = p;
        }
        const ah = p.left ? p.left.height : 0;
        const bh = b ? b.height : 0;
        const ch = q.right ? q.right.height : 0;
        p.height = Math.max(ah, bh) + 1;
        q.height = Math.max(ch, p.height) + 1;
        return q;
      }
      /**
       * Modify the tree if its right subtree is too small compared to the left
       * Return the new root if any
       */
      rightTooSmall() {
        if (this.balanceFactor() <= 1)
          return this;
        if (this.left.balanceFactor() < 0)
          this.left.leftRotation();
        return this.rightRotation();
      }
      /**
       * Modify the tree if its left subtree is too small compared to the right
       * Return the new root if any
       */
      leftTooSmall() {
        if (this.balanceFactor() >= -1) {
          return this;
        }
        if (this.right.balanceFactor() > 0)
          this.right.rightRotation();
        return this.leftRotation();
      }
      /**
       * Rebalance the tree along the given path. The path is given reversed (as he was calculated
       * in the insert and delete functions).
       * Returns the new root of the tree
       * Of course, the first element of the path must be the root of the tree
       */
      rebalanceAlongPath(path) {
        let newRoot = this;
        let rotated;
        let i;
        if (!Object.prototype.hasOwnProperty.call(this, "key")) {
          delete this.height;
          return this;
        }
        for (i = path.length - 1; i >= 0; i -= 1) {
          path[i].height = 1 + Math.max(path[i].left ? path[i].left.height : 0, path[i].right ? path[i].right.height : 0);
          if (path[i].balanceFactor() > 1) {
            rotated = path[i].rightTooSmall();
            if (i === 0)
              newRoot = rotated;
          }
          if (path[i].balanceFactor() < -1) {
            rotated = path[i].leftTooSmall();
            if (i === 0)
              newRoot = rotated;
          }
        }
        return newRoot;
      }
      /**
       * Insert a key, value pair in the tree while maintaining the AVL tree height constraint
       * Return a pointer to the root node, which may have changed
       */
      insert(key, value) {
        const insertPath = [];
        let currentNode = this;
        if (!Object.prototype.hasOwnProperty.call(this, "key")) {
          this.key = key;
          this.data.push(value);
          this.height = 1;
          return this;
        }
        while (true) {
          if (currentNode.compareKeys(currentNode.key, key) === 0) {
            if (currentNode.unique) {
              const err = new Error(`Can't insert key ${JSON.stringify(key)}, it violates the unique constraint`);
              err.key = key;
              err.errorType = "uniqueViolated";
              throw err;
            } else
              currentNode.data.push(value);
            return this;
          }
          insertPath.push(currentNode);
          if (currentNode.compareKeys(key, currentNode.key) < 0) {
            if (!currentNode.left) {
              insertPath.push(currentNode.createLeftChild({ key, value }));
              break;
            } else
              currentNode = currentNode.left;
          } else {
            if (!currentNode.right) {
              insertPath.push(currentNode.createRightChild({ key, value }));
              break;
            } else
              currentNode = currentNode.right;
          }
        }
        return this.rebalanceAlongPath(insertPath);
      }
      /**
       * Delete a key or just a value and return the new root of the tree
       * @param {Key} key
       * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted
       */
      delete(key, value) {
        const newData = [];
        let replaceWith;
        let currentNode = this;
        const deletePath = [];
        if (!Object.prototype.hasOwnProperty.call(this, "key"))
          return this;
        while (true) {
          if (currentNode.compareKeys(key, currentNode.key) === 0) {
            break;
          }
          deletePath.push(currentNode);
          if (currentNode.compareKeys(key, currentNode.key) < 0) {
            if (currentNode.left) {
              currentNode = currentNode.left;
            } else
              return this;
          } else {
            if (currentNode.right) {
              currentNode = currentNode.right;
            } else
              return this;
          }
        }
        if (currentNode.data.length > 1 && value !== void 0) {
          currentNode.data.forEach(function(d) {
            if (!currentNode.checkValueEquality(d, value))
              newData.push(d);
          });
          currentNode.data = newData;
          return this;
        }
        if (!currentNode.left && !currentNode.right) {
          if (currentNode === this) {
            delete currentNode.key;
            currentNode.data = [];
            delete currentNode.height;
            return this;
          } else {
            if (currentNode.parent.left === currentNode)
              currentNode.parent.left = null;
            else
              currentNode.parent.right = null;
            return this.rebalanceAlongPath(deletePath);
          }
        }
        if (!currentNode.left || !currentNode.right) {
          replaceWith = currentNode.left ? currentNode.left : currentNode.right;
          if (currentNode === this) {
            replaceWith.parent = null;
            return replaceWith;
          } else {
            if (currentNode.parent.left === currentNode) {
              currentNode.parent.left = replaceWith;
              replaceWith.parent = currentNode.parent;
            } else {
              currentNode.parent.right = replaceWith;
              replaceWith.parent = currentNode.parent;
            }
            return this.rebalanceAlongPath(deletePath);
          }
        }
        deletePath.push(currentNode);
        replaceWith = currentNode.left;
        if (!replaceWith.right) {
          currentNode.key = replaceWith.key;
          currentNode.data = replaceWith.data;
          currentNode.left = replaceWith.left;
          if (replaceWith.left) {
            replaceWith.left.parent = currentNode;
          }
          return this.rebalanceAlongPath(deletePath);
        }
        while (true) {
          if (replaceWith.right) {
            deletePath.push(replaceWith);
            replaceWith = replaceWith.right;
          } else
            break;
        }
        currentNode.key = replaceWith.key;
        currentNode.data = replaceWith.data;
        replaceWith.parent.right = replaceWith.left;
        if (replaceWith.left)
          replaceWith.left.parent = replaceWith.parent;
        return this.rebalanceAlongPath(deletePath);
      }
    };
    AVLTree._AVLTree = _AVLTree;
    ["getNumberOfKeys", "search", "betweenBounds", "prettyPrint", "executeOnEveryNode"].forEach(function(fn) {
      AVLTree.prototype[fn] = function() {
        return this.tree[fn].apply(this.tree, arguments);
      };
    });
    module.exports = AVLTree;
  }
});

// node_modules/@seald-io/binary-search-tree/index.js
var require_binary_search_tree = __commonJS({
  "node_modules/@seald-io/binary-search-tree/index.js"(exports, module) {
    module.exports.BinarySearchTree = require_bst();
    module.exports.AVLTree = require_avltree();
  }
});

// node_modules/@seald-io/nedb/lib/indexes.js
var require_indexes = __commonJS({
  "node_modules/@seald-io/nedb/lib/indexes.js"(exports, module) {
    var BinarySearchTree = require_binary_search_tree().AVLTree;
    var model = require_model();
    var { uniq, isDate } = require_utils();
    var checkValueEquality = (a, b) => a === b;
    var projectForUnique = (elt) => {
      if (elt === null)
        return "$null";
      if (typeof elt === "string")
        return "$string" + elt;
      if (typeof elt === "boolean")
        return "$boolean" + elt;
      if (typeof elt === "number")
        return "$number" + elt;
      if (isDate(elt))
        return "$date" + elt.getTime();
      return elt;
    };
    var Index = class {
      /**
       * Create a new index
       * All methods on an index guarantee that either the whole operation was successful and the index changed
       * or the operation was unsuccessful and an error is thrown while the index is unchanged
       * @param {object} options
       * @param {string} options.fieldName On which field should the index apply, can use dot notation to index on sub fields, can use comma-separated notation to use compound indexes
       * @param {boolean} [options.unique = false] Enforces a unique constraint
       * @param {boolean} [options.sparse = false] Allows a sparse index (we can have documents for which fieldName is `undefined`)
       */
      constructor(options) {
        this.fieldName = options.fieldName;
        if (typeof this.fieldName !== "string")
          throw new Error("fieldName must be a string");
        this._fields = this.fieldName.split(",");
        this.unique = options.unique || false;
        this.sparse = options.sparse || false;
        this.treeOptions = { unique: this.unique, compareKeys: model.compareThings, checkValueEquality };
        this.tree = new BinarySearchTree(this.treeOptions);
      }
      /**
       * Reset an index
       * @param {?document|?document[]} [newData] Data to initialize the index with. If an error is thrown during
       * insertion, the index is not modified.
       */
      reset(newData) {
        this.tree = new BinarySearchTree(this.treeOptions);
        if (newData)
          this.insert(newData);
      }
      /**
       * Insert a new document in the index
       * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)
       * O(log(n))
       * @param {document|document[]} doc The document, or array of documents, to insert.
       */
      insert(doc) {
        let keys;
        let failingIndex;
        let error;
        if (Array.isArray(doc)) {
          this.insertMultipleDocs(doc);
          return;
        }
        const key = model.getDotValues(doc, this._fields);
        if ((key === void 0 || typeof key === "object" && key !== null && Object.values(key).every((el) => el === void 0)) && this.sparse)
          return;
        if (!Array.isArray(key))
          this.tree.insert(key, doc);
        else {
          keys = uniq(key, projectForUnique);
          for (let i = 0; i < keys.length; i += 1) {
            try {
              this.tree.insert(keys[i], doc);
            } catch (e) {
              error = e;
              failingIndex = i;
              break;
            }
          }
          if (error) {
            for (let i = 0; i < failingIndex; i += 1) {
              this.tree.delete(keys[i], doc);
            }
            throw error;
          }
        }
      }
      /**
       * Insert an array of documents in the index
       * If a constraint is violated, the changes should be rolled back and an error thrown
       * @param {document[]} docs Array of documents to insert.
       * @private
       */
      insertMultipleDocs(docs) {
        let error;
        let failingIndex;
        for (let i = 0; i < docs.length; i += 1) {
          try {
            this.insert(docs[i]);
          } catch (e) {
            error = e;
            failingIndex = i;
            break;
          }
        }
        if (error) {
          for (let i = 0; i < failingIndex; i += 1) {
            this.remove(docs[i]);
          }
          throw error;
        }
      }
      /**
       * Removes a document from the index.
       * If an array is passed, we remove all its elements
       * The remove operation is safe with regards to the 'unique' constraint
       * O(log(n))
       * @param {document[]|document} doc The document, or Array of documents, to remove.
       */
      remove(doc) {
        if (Array.isArray(doc)) {
          doc.forEach((d) => {
            this.remove(d);
          });
          return;
        }
        const key = model.getDotValues(doc, this._fields);
        if (key === void 0 && this.sparse)
          return;
        if (!Array.isArray(key)) {
          this.tree.delete(key, doc);
        } else {
          uniq(key, projectForUnique).forEach((_key) => {
            this.tree.delete(_key, doc);
          });
        }
      }
      /**
       * Update a document in the index
       * If a constraint is violated, changes are rolled back and an error thrown
       * Naive implementation, still in O(log(n))
       * @param {document|Array.<{oldDoc: document, newDoc: document}>} oldDoc Document to update, or an `Array` of
       * `{oldDoc, newDoc}` pairs.
       * @param {document} [newDoc] Document to replace the oldDoc with. If the first argument is an `Array` of
       * `{oldDoc, newDoc}` pairs, this second argument is ignored.
       */
      update(oldDoc, newDoc) {
        if (Array.isArray(oldDoc)) {
          this.updateMultipleDocs(oldDoc);
          return;
        }
        this.remove(oldDoc);
        try {
          this.insert(newDoc);
        } catch (e) {
          this.insert(oldDoc);
          throw e;
        }
      }
      /**
       * Update multiple documents in the index
       * If a constraint is violated, the changes need to be rolled back
       * and an error thrown
       * @param {Array.<{oldDoc: document, newDoc: document}>} pairs
       *
       * @private
       */
      updateMultipleDocs(pairs) {
        let failingIndex;
        let error;
        for (let i = 0; i < pairs.length; i += 1) {
          this.remove(pairs[i].oldDoc);
        }
        for (let i = 0; i < pairs.length; i += 1) {
          try {
            this.insert(pairs[i].newDoc);
          } catch (e) {
            error = e;
            failingIndex = i;
            break;
          }
        }
        if (error) {
          for (let i = 0; i < failingIndex; i += 1) {
            this.remove(pairs[i].newDoc);
          }
          for (let i = 0; i < pairs.length; i += 1) {
            this.insert(pairs[i].oldDoc);
          }
          throw error;
        }
      }
      /**
       * Revert an update
       * @param {document|Array.<{oldDoc: document, newDoc: document}>} oldDoc Document to revert to, or an `Array` of `{oldDoc, newDoc}` pairs.
       * @param {document} [newDoc] Document to revert from. If the first argument is an Array of {oldDoc, newDoc}, this second argument is ignored.
       */
      revertUpdate(oldDoc, newDoc) {
        const revert = [];
        if (!Array.isArray(oldDoc))
          this.update(newDoc, oldDoc);
        else {
          oldDoc.forEach((pair) => {
            revert.push({ oldDoc: pair.newDoc, newDoc: pair.oldDoc });
          });
          this.update(revert);
        }
      }
      /**
       * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)
       * @param {Array.<*>|*} value Value to match the key against
       * @return {document[]}
       */
      getMatching(value) {
        if (!Array.isArray(value))
          return this.tree.search(value);
        else {
          const _res = {};
          const res = [];
          value.forEach((v) => {
            this.getMatching(v).forEach((doc) => {
              _res[doc._id] = doc;
            });
          });
          Object.keys(_res).forEach((_id) => {
            res.push(_res[_id]);
          });
          return res;
        }
      }
      /**
       * Get all documents in index whose key is between bounds are they are defined by query
       * Documents are sorted by key
       * @param {object} query An object with at least one matcher among $gt, $gte, $lt, $lte.
       * @param {*} [query.$gt] Greater than matcher.
       * @param {*} [query.$gte] Greater than or equal matcher.
       * @param {*} [query.$lt] Lower than matcher.
       * @param {*} [query.$lte] Lower than or equal matcher.
       * @return {document[]}
       */
      getBetweenBounds(query) {
        return this.tree.betweenBounds(query);
      }
      /**
       * Get all elements in the index
       * @return {document[]}
       */
      getAll() {
        const res = [];
        this.tree.executeOnEveryNode((node) => {
          res.push(...node.data);
        });
        return res;
      }
    };
    module.exports = Index;
  }
});

// node_modules/@seald-io/nedb/browser-version/lib/byline.js
var require_byline = __commonJS({
  "node_modules/@seald-io/nedb/browser-version/lib/byline.js"(exports, module) {
    module.exports = {};
  }
});

// node_modules/localforage/dist/localforage.js
var require_localforage = __commonJS({
  "node_modules/localforage/dist/localforage.js"(exports, module) {
    (function(f) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.localforage = f();
      }
    })(function() {
      var define2, module2, exports2;
      return function e(t, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof __require == "function" && __require;
              if (!u && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f = new Error("Cannot find module '" + o2 + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o2] = { exports: {} };
            t[o2][0].call(l.exports, function(e2) {
              var n2 = t[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l, l.exports, e, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof __require == "function" && __require;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(_dereq_, module3, exports3) {
        (function(global2) {
          "use strict";
          var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
          var scheduleDrain;
          {
            if (Mutation) {
              var called = 0;
              var observer = new Mutation(nextTick);
              var element = global2.document.createTextNode("");
              observer.observe(element, {
                characterData: true
              });
              scheduleDrain = function() {
                element.data = called = ++called % 2;
              };
            } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
              var channel = new global2.MessageChannel();
              channel.port1.onmessage = nextTick;
              scheduleDrain = function() {
                channel.port2.postMessage(0);
              };
            } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
              scheduleDrain = function() {
                var scriptEl = global2.document.createElement("script");
                scriptEl.onreadystatechange = function() {
                  nextTick();
                  scriptEl.onreadystatechange = null;
                  scriptEl.parentNode.removeChild(scriptEl);
                  scriptEl = null;
                };
                global2.document.documentElement.appendChild(scriptEl);
              };
            } else {
              scheduleDrain = function() {
                setTimeout(nextTick, 0);
              };
            }
          }
          var draining;
          var queue = [];
          function nextTick() {
            draining = true;
            var i, oldQueue;
            var len = queue.length;
            while (len) {
              oldQueue = queue;
              queue = [];
              i = -1;
              while (++i < len) {
                oldQueue[i]();
              }
              len = queue.length;
            }
            draining = false;
          }
          module3.exports = immediate;
          function immediate(task) {
            if (queue.push(task) === 1 && !draining) {
              scheduleDrain();
            }
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 2: [function(_dereq_, module3, exports3) {
        "use strict";
        var immediate = _dereq_(1);
        function INTERNAL() {
        }
        var handlers = {};
        var REJECTED = ["REJECTED"];
        var FULFILLED = ["FULFILLED"];
        var PENDING = ["PENDING"];
        module3.exports = Promise2;
        function Promise2(resolver) {
          if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function");
          }
          this.state = PENDING;
          this.queue = [];
          this.outcome = void 0;
          if (resolver !== INTERNAL) {
            safelyResolveThenable(this, resolver);
          }
        }
        Promise2.prototype["catch"] = function(onRejected) {
          return this.then(null, onRejected);
        };
        Promise2.prototype.then = function(onFulfilled, onRejected) {
          if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
            return this;
          }
          var promise = new this.constructor(INTERNAL);
          if (this.state !== PENDING) {
            var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
            unwrap(promise, resolver, this.outcome);
          } else {
            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
          }
          return promise;
        };
        function QueueItem(promise, onFulfilled, onRejected) {
          this.promise = promise;
          if (typeof onFulfilled === "function") {
            this.onFulfilled = onFulfilled;
            this.callFulfilled = this.otherCallFulfilled;
          }
          if (typeof onRejected === "function") {
            this.onRejected = onRejected;
            this.callRejected = this.otherCallRejected;
          }
        }
        QueueItem.prototype.callFulfilled = function(value) {
          handlers.resolve(this.promise, value);
        };
        QueueItem.prototype.otherCallFulfilled = function(value) {
          unwrap(this.promise, this.onFulfilled, value);
        };
        QueueItem.prototype.callRejected = function(value) {
          handlers.reject(this.promise, value);
        };
        QueueItem.prototype.otherCallRejected = function(value) {
          unwrap(this.promise, this.onRejected, value);
        };
        function unwrap(promise, func, value) {
          immediate(function() {
            var returnValue;
            try {
              returnValue = func(value);
            } catch (e) {
              return handlers.reject(promise, e);
            }
            if (returnValue === promise) {
              handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
            } else {
              handlers.resolve(promise, returnValue);
            }
          });
        }
        handlers.resolve = function(self2, value) {
          var result = tryCatch(getThen, value);
          if (result.status === "error") {
            return handlers.reject(self2, result.value);
          }
          var thenable = result.value;
          if (thenable) {
            safelyResolveThenable(self2, thenable);
          } else {
            self2.state = FULFILLED;
            self2.outcome = value;
            var i = -1;
            var len = self2.queue.length;
            while (++i < len) {
              self2.queue[i].callFulfilled(value);
            }
          }
          return self2;
        };
        handlers.reject = function(self2, error) {
          self2.state = REJECTED;
          self2.outcome = error;
          var i = -1;
          var len = self2.queue.length;
          while (++i < len) {
            self2.queue[i].callRejected(error);
          }
          return self2;
        };
        function getThen(obj) {
          var then = obj && obj.then;
          if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
            return function appyThen() {
              then.apply(obj, arguments);
            };
          }
        }
        function safelyResolveThenable(self2, thenable) {
          var called = false;
          function onError(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.reject(self2, value);
          }
          function onSuccess(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.resolve(self2, value);
          }
          function tryToUnwrap() {
            thenable(onSuccess, onError);
          }
          var result = tryCatch(tryToUnwrap);
          if (result.status === "error") {
            onError(result.value);
          }
        }
        function tryCatch(func, value) {
          var out = {};
          try {
            out.value = func(value);
            out.status = "success";
          } catch (e) {
            out.status = "error";
            out.value = e;
          }
          return out;
        }
        Promise2.resolve = resolve;
        function resolve(value) {
          if (value instanceof this) {
            return value;
          }
          return handlers.resolve(new this(INTERNAL), value);
        }
        Promise2.reject = reject;
        function reject(reason) {
          var promise = new this(INTERNAL);
          return handlers.reject(promise, reason);
        }
        Promise2.all = all;
        function all(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var values = new Array(len);
          var resolved = 0;
          var i = -1;
          var promise = new this(INTERNAL);
          while (++i < len) {
            allResolver(iterable[i], i);
          }
          return promise;
          function allResolver(value, i2) {
            self2.resolve(value).then(resolveFromAll, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
            function resolveFromAll(outValue) {
              values[i2] = outValue;
              if (++resolved === len && !called) {
                called = true;
                handlers.resolve(promise, values);
              }
            }
          }
        }
        Promise2.race = race;
        function race(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var i = -1;
          var promise = new this(INTERNAL);
          while (++i < len) {
            resolver(iterable[i]);
          }
          return promise;
          function resolver(value) {
            self2.resolve(value).then(function(response) {
              if (!called) {
                called = true;
                handlers.resolve(promise, response);
              }
            }, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
          }
        }
      }, { "1": 1 }], 3: [function(_dereq_, module3, exports3) {
        (function(global2) {
          "use strict";
          if (typeof global2.Promise !== "function") {
            global2.Promise = _dereq_(2);
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "2": 2 }], 4: [function(_dereq_, module3, exports3) {
        "use strict";
        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function getIDB() {
          try {
            if (typeof indexedDB !== "undefined") {
              return indexedDB;
            }
            if (typeof webkitIndexedDB !== "undefined") {
              return webkitIndexedDB;
            }
            if (typeof mozIndexedDB !== "undefined") {
              return mozIndexedDB;
            }
            if (typeof OIndexedDB !== "undefined") {
              return OIndexedDB;
            }
            if (typeof msIndexedDB !== "undefined") {
              return msIndexedDB;
            }
          } catch (e) {
            return;
          }
        }
        var idb = getIDB();
        function isIndexedDBValid() {
          try {
            if (!idb || !idb.open) {
              return false;
            }
            var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
            var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
            return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && // some outdated implementations of IDB that appear on Samsung
            // and HTC Android devices <4.4 are missing IDBKeyRange
            // See: https://github.com/mozilla/localForage/issues/128
            // See: https://github.com/mozilla/localForage/issues/272
            typeof IDBKeyRange !== "undefined";
          } catch (e) {
            return false;
          }
        }
        function createBlob(parts, properties) {
          parts = parts || [];
          properties = properties || {};
          try {
            return new Blob(parts, properties);
          } catch (e) {
            if (e.name !== "TypeError") {
              throw e;
            }
            var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
            var builder = new Builder();
            for (var i = 0; i < parts.length; i += 1) {
              builder.append(parts[i]);
            }
            return builder.getBlob(properties.type);
          }
        }
        if (typeof Promise === "undefined") {
          _dereq_(3);
        }
        var Promise$1 = Promise;
        function executeCallback(promise, callback) {
          if (callback) {
            promise.then(function(result) {
              callback(null, result);
            }, function(error) {
              callback(error);
            });
          }
        }
        function executeTwoCallbacks(promise, callback, errorCallback) {
          if (typeof callback === "function") {
            promise.then(callback);
          }
          if (typeof errorCallback === "function") {
            promise["catch"](errorCallback);
          }
        }
        function normalizeKey(key2) {
          if (typeof key2 !== "string") {
            console.warn(key2 + " used as a key, but it is not a string.");
            key2 = String(key2);
          }
          return key2;
        }
        function getCallback() {
          if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
            return arguments[arguments.length - 1];
          }
        }
        var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
        var supportsBlobs = void 0;
        var dbContexts = {};
        var toString = Object.prototype.toString;
        var READ_ONLY = "readonly";
        var READ_WRITE = "readwrite";
        function _binStringToArrayBuffer(bin) {
          var length2 = bin.length;
          var buf = new ArrayBuffer(length2);
          var arr = new Uint8Array(buf);
          for (var i = 0; i < length2; i++) {
            arr[i] = bin.charCodeAt(i);
          }
          return buf;
        }
        function _checkBlobSupportWithoutCaching(idb2) {
          return new Promise$1(function(resolve) {
            var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
            var blob = createBlob([""]);
            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
            txn.onabort = function(e) {
              e.preventDefault();
              e.stopPropagation();
              resolve(false);
            };
            txn.oncomplete = function() {
              var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
              var matchedEdge = navigator.userAgent.match(/Edge\//);
              resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
            };
          })["catch"](function() {
            return false;
          });
        }
        function _checkBlobSupport(idb2) {
          if (typeof supportsBlobs === "boolean") {
            return Promise$1.resolve(supportsBlobs);
          }
          return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
            supportsBlobs = value;
            return supportsBlobs;
          });
        }
        function _deferReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = {};
          deferredOperation.promise = new Promise$1(function(resolve, reject) {
            deferredOperation.resolve = resolve;
            deferredOperation.reject = reject;
          });
          dbContext.deferredOperations.push(deferredOperation);
          if (!dbContext.dbReady) {
            dbContext.dbReady = deferredOperation.promise;
          } else {
            dbContext.dbReady = dbContext.dbReady.then(function() {
              return deferredOperation.promise;
            });
          }
        }
        function _advanceReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.resolve();
            return deferredOperation.promise;
          }
        }
        function _rejectReadiness(dbInfo, err) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.reject(err);
            return deferredOperation.promise;
          }
        }
        function _getConnection(dbInfo, upgradeNeeded) {
          return new Promise$1(function(resolve, reject) {
            dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
            if (dbInfo.db) {
              if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
              } else {
                return resolve(dbInfo.db);
              }
            }
            var dbArgs = [dbInfo.name];
            if (upgradeNeeded) {
              dbArgs.push(dbInfo.version);
            }
            var openreq = idb.open.apply(idb, dbArgs);
            if (upgradeNeeded) {
              openreq.onupgradeneeded = function(e) {
                var db = openreq.result;
                try {
                  db.createObjectStore(dbInfo.storeName);
                  if (e.oldVersion <= 1) {
                    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                  }
                } catch (ex) {
                  if (ex.name === "ConstraintError") {
                    console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e.oldVersion + " to version " + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                  } else {
                    throw ex;
                  }
                }
              };
            }
            openreq.onerror = function(e) {
              e.preventDefault();
              reject(openreq.error);
            };
            openreq.onsuccess = function() {
              var db = openreq.result;
              db.onversionchange = function(e) {
                e.target.close();
              };
              resolve(db);
              _advanceReadiness(dbInfo);
            };
          });
        }
        function _getOriginalConnection(dbInfo) {
          return _getConnection(dbInfo, false);
        }
        function _getUpgradedConnection(dbInfo) {
          return _getConnection(dbInfo, true);
        }
        function _isUpgradeNeeded(dbInfo, defaultVersion) {
          if (!dbInfo.db) {
            return true;
          }
          var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
          var isDowngrade = dbInfo.version < dbInfo.db.version;
          var isUpgrade = dbInfo.version > dbInfo.db.version;
          if (isDowngrade) {
            if (dbInfo.version !== defaultVersion) {
              console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
            }
            dbInfo.version = dbInfo.db.version;
          }
          if (isUpgrade || isNewStore) {
            if (isNewStore) {
              var incVersion = dbInfo.db.version + 1;
              if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
              }
            }
            return true;
          }
          return false;
        }
        function _encodeBlob(blob) {
          return new Promise$1(function(resolve, reject) {
            var reader = new FileReader();
            reader.onerror = reject;
            reader.onloadend = function(e) {
              var base64 = btoa(e.target.result || "");
              resolve({
                __local_forage_encoded_blob: true,
                data: base64,
                type: blob.type
              });
            };
            reader.readAsBinaryString(blob);
          });
        }
        function _decodeBlob(encodedBlob) {
          var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
          return createBlob([arrayBuff], { type: encodedBlob.type });
        }
        function _isEncodedBlob(value) {
          return value && value.__local_forage_encoded_blob;
        }
        function _fullyReady(callback) {
          var self2 = this;
          var promise = self2._initReady().then(function() {
            var dbContext = dbContexts[self2._dbInfo.name];
            if (dbContext && dbContext.dbReady) {
              return dbContext.dbReady;
            }
          });
          executeTwoCallbacks(promise, callback, callback);
          return promise;
        }
        function _tryReconnect(dbInfo) {
          _deferReadiness(dbInfo);
          var dbContext = dbContexts[dbInfo.name];
          var forages = dbContext.forages;
          for (var i = 0; i < forages.length; i++) {
            var forage = forages[i];
            if (forage._dbInfo.db) {
              forage._dbInfo.db.close();
              forage._dbInfo.db = null;
            }
          }
          dbInfo.db = null;
          return _getOriginalConnection(dbInfo).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            for (var i2 = 0; i2 < forages.length; i2++) {
              forages[i2]._dbInfo.db = db;
            }
          })["catch"](function(err) {
            _rejectReadiness(dbInfo, err);
            throw err;
          });
        }
        function createTransaction(dbInfo, mode, callback, retries) {
          if (retries === void 0) {
            retries = 1;
          }
          try {
            var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
            callback(null, tx);
          } catch (err) {
            if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
              return Promise$1.resolve().then(function() {
                if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                  if (dbInfo.db) {
                    dbInfo.version = dbInfo.db.version + 1;
                  }
                  return _getUpgradedConnection(dbInfo);
                }
              }).then(function() {
                return _tryReconnect(dbInfo).then(function() {
                  createTransaction(dbInfo, mode, callback, retries - 1);
                });
              })["catch"](callback);
            }
            callback(err);
          }
        }
        function createDbContext() {
          return {
            // Running localForages sharing a database.
            forages: [],
            // Shared database.
            db: null,
            // Database readiness (promise).
            dbReady: null,
            // Deferred operations on the database.
            deferredOperations: []
          };
        }
        function _initStorage(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i in options) {
              dbInfo[i] = options[i];
            }
          }
          var dbContext = dbContexts[dbInfo.name];
          if (!dbContext) {
            dbContext = createDbContext();
            dbContexts[dbInfo.name] = dbContext;
          }
          dbContext.forages.push(self2);
          if (!self2._initReady) {
            self2._initReady = self2.ready;
            self2.ready = _fullyReady;
          }
          var initPromises = [];
          function ignoreErrors() {
            return Promise$1.resolve();
          }
          for (var j = 0; j < dbContext.forages.length; j++) {
            var forage = dbContext.forages[j];
            if (forage !== self2) {
              initPromises.push(forage._initReady()["catch"](ignoreErrors));
            }
          }
          var forages = dbContext.forages.slice(0);
          return Promise$1.all(initPromises).then(function() {
            dbInfo.db = dbContext.db;
            return _getOriginalConnection(dbInfo);
          }).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            self2._dbInfo = dbInfo;
            for (var k = 0; k < forages.length; k++) {
              var forage2 = forages[k];
              if (forage2 !== self2) {
                forage2._dbInfo.db = dbInfo.db;
                forage2._dbInfo.version = dbInfo.version;
              }
            }
          });
        }
        function getItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.get(key2);
                  req.onsuccess = function() {
                    var value = req.result;
                    if (value === void 0) {
                      value = null;
                    }
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    resolve(value);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openCursor();
                  var iterationNumber = 1;
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (cursor) {
                      var value = cursor.value;
                      if (_isEncodedBlob(value)) {
                        value = _decodeBlob(value);
                      }
                      var result = iterator(value, cursor.key, iterationNumber++);
                      if (result !== void 0) {
                        resolve(result);
                      } else {
                        cursor["continue"]();
                      }
                    } else {
                      resolve();
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            var dbInfo;
            self2.ready().then(function() {
              dbInfo = self2._dbInfo;
              if (toString.call(value) === "[object Blob]") {
                return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                  if (blobSupport) {
                    return value;
                  }
                  return _encodeBlob(value);
                });
              }
              return value;
            }).then(function(value2) {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  if (value2 === null) {
                    value2 = void 0;
                  }
                  var req = store.put(value2, key2);
                  transaction.oncomplete = function() {
                    if (value2 === void 0) {
                      value2 = null;
                    }
                    resolve(value2);
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store["delete"](key2);
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onerror = function() {
                    reject(req.error);
                  };
                  transaction.onabort = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.clear();
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.count();
                  req.onsuccess = function() {
                    resolve(req.result);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key(n, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            if (n < 0) {
              resolve(null);
              return;
            }
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var advanced = false;
                  var req = store.openKeyCursor();
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve(null);
                      return;
                    }
                    if (n === 0) {
                      resolve(cursor.key);
                    } else {
                      if (!advanced) {
                        advanced = true;
                        cursor.advance(n);
                      } else {
                        resolve(cursor.key);
                      }
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openKeyCursor();
                  var keys2 = [];
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve(keys2);
                      return;
                    }
                    keys2.push(cursor.key);
                    cursor["continue"]();
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
            var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db) {
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              dbContext.db = db;
              for (var i = 0; i < forages.length; i++) {
                forages[i]._dbInfo.db = db;
              }
              return db;
            });
            if (!options.storeName) {
              promise = dbPromise.then(function(db) {
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i = 0; i < forages.length; i++) {
                  var forage = forages[i];
                  forage._dbInfo.db = null;
                }
                var dropDBPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.deleteDatabase(options.name);
                  req.onerror = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    reject(req.error);
                  };
                  req.onblocked = function() {
                    console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    resolve(db2);
                  };
                });
                return dropDBPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var i2 = 0; i2 < forages.length; i2++) {
                    var _forage = forages[i2];
                    _advanceReadiness(_forage._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            } else {
              promise = dbPromise.then(function(db) {
                if (!db.objectStoreNames.contains(options.storeName)) {
                  return;
                }
                var newVersion = db.version + 1;
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i = 0; i < forages.length; i++) {
                  var forage = forages[i];
                  forage._dbInfo.db = null;
                  forage._dbInfo.version = newVersion;
                }
                var dropObjectPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.open(options.name, newVersion);
                  req.onerror = function(err) {
                    var db2 = req.result;
                    db2.close();
                    reject(err);
                  };
                  req.onupgradeneeded = function() {
                    var db2 = req.result;
                    db2.deleteObjectStore(options.storeName);
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    db2.close();
                    resolve(db2);
                  };
                });
                return dropObjectPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var j = 0; j < forages.length; j++) {
                    var _forage2 = forages[j];
                    _forage2._dbInfo.db = db2;
                    _advanceReadiness(_forage2._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            }
          }
          executeCallback(promise, callback);
          return promise;
        }
        var asyncStorage = {
          _driver: "asyncStorage",
          _initStorage,
          _support: isIndexedDBValid(),
          iterate,
          getItem,
          setItem,
          removeItem,
          clear,
          length,
          key,
          keys,
          dropInstance
        };
        function isWebSQLValid() {
          return typeof openDatabase === "function";
        }
        var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var BLOB_TYPE_PREFIX = "~~local_forage_type~";
        var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
        var SERIALIZED_MARKER = "__lfsc__:";
        var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
        var TYPE_ARRAYBUFFER = "arbf";
        var TYPE_BLOB = "blob";
        var TYPE_INT8ARRAY = "si08";
        var TYPE_UINT8ARRAY = "ui08";
        var TYPE_UINT8CLAMPEDARRAY = "uic8";
        var TYPE_INT16ARRAY = "si16";
        var TYPE_INT32ARRAY = "si32";
        var TYPE_UINT16ARRAY = "ur16";
        var TYPE_UINT32ARRAY = "ui32";
        var TYPE_FLOAT32ARRAY = "fl32";
        var TYPE_FLOAT64ARRAY = "fl64";
        var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
        var toString$1 = Object.prototype.toString;
        function stringToBuffer(serializedString) {
          var bufferLength = serializedString.length * 0.75;
          var len = serializedString.length;
          var i;
          var p = 0;
          var encoded1, encoded2, encoded3, encoded4;
          if (serializedString[serializedString.length - 1] === "=") {
            bufferLength--;
            if (serializedString[serializedString.length - 2] === "=") {
              bufferLength--;
            }
          }
          var buffer = new ArrayBuffer(bufferLength);
          var bytes = new Uint8Array(buffer);
          for (i = 0; i < len; i += 4) {
            encoded1 = BASE_CHARS.indexOf(serializedString[i]);
            encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
            encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
            encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return buffer;
        }
        function bufferToString(buffer) {
          var bytes = new Uint8Array(buffer);
          var base64String = "";
          var i;
          for (i = 0; i < bytes.length; i += 3) {
            base64String += BASE_CHARS[bytes[i] >> 2];
            base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
            base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
            base64String += BASE_CHARS[bytes[i + 2] & 63];
          }
          if (bytes.length % 3 === 2) {
            base64String = base64String.substring(0, base64String.length - 1) + "=";
          } else if (bytes.length % 3 === 1) {
            base64String = base64String.substring(0, base64String.length - 2) + "==";
          }
          return base64String;
        }
        function serialize(value, callback) {
          var valueType = "";
          if (value) {
            valueType = toString$1.call(value);
          }
          if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
            var buffer;
            var marker = SERIALIZED_MARKER;
            if (value instanceof ArrayBuffer) {
              buffer = value;
              marker += TYPE_ARRAYBUFFER;
            } else {
              buffer = value.buffer;
              if (valueType === "[object Int8Array]") {
                marker += TYPE_INT8ARRAY;
              } else if (valueType === "[object Uint8Array]") {
                marker += TYPE_UINT8ARRAY;
              } else if (valueType === "[object Uint8ClampedArray]") {
                marker += TYPE_UINT8CLAMPEDARRAY;
              } else if (valueType === "[object Int16Array]") {
                marker += TYPE_INT16ARRAY;
              } else if (valueType === "[object Uint16Array]") {
                marker += TYPE_UINT16ARRAY;
              } else if (valueType === "[object Int32Array]") {
                marker += TYPE_INT32ARRAY;
              } else if (valueType === "[object Uint32Array]") {
                marker += TYPE_UINT32ARRAY;
              } else if (valueType === "[object Float32Array]") {
                marker += TYPE_FLOAT32ARRAY;
              } else if (valueType === "[object Float64Array]") {
                marker += TYPE_FLOAT64ARRAY;
              } else {
                callback(new Error("Failed to get type for BinaryArray"));
              }
            }
            callback(marker + bufferToString(buffer));
          } else if (valueType === "[object Blob]") {
            var fileReader = new FileReader();
            fileReader.onload = function() {
              var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
              callback(SERIALIZED_MARKER + TYPE_BLOB + str);
            };
            fileReader.readAsArrayBuffer(value);
          } else {
            try {
              callback(JSON.stringify(value));
            } catch (e) {
              console.error("Couldn't convert value into a JSON string: ", value);
              callback(null, e);
            }
          }
        }
        function deserialize(value) {
          if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
            return JSON.parse(value);
          }
          var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
          var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
          var blobType;
          if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
            var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
            blobType = matcher[1];
            serializedString = serializedString.substring(matcher[0].length);
          }
          var buffer = stringToBuffer(serializedString);
          switch (type) {
            case TYPE_ARRAYBUFFER:
              return buffer;
            case TYPE_BLOB:
              return createBlob([buffer], { type: blobType });
            case TYPE_INT8ARRAY:
              return new Int8Array(buffer);
            case TYPE_UINT8ARRAY:
              return new Uint8Array(buffer);
            case TYPE_UINT8CLAMPEDARRAY:
              return new Uint8ClampedArray(buffer);
            case TYPE_INT16ARRAY:
              return new Int16Array(buffer);
            case TYPE_UINT16ARRAY:
              return new Uint16Array(buffer);
            case TYPE_INT32ARRAY:
              return new Int32Array(buffer);
            case TYPE_UINT32ARRAY:
              return new Uint32Array(buffer);
            case TYPE_FLOAT32ARRAY:
              return new Float32Array(buffer);
            case TYPE_FLOAT64ARRAY:
              return new Float64Array(buffer);
            default:
              throw new Error("Unkown type: " + type);
          }
        }
        var localforageSerializer = {
          serialize,
          deserialize,
          stringToBuffer,
          bufferToString
        };
        function createDbTable(t, dbInfo, callback, errorCallback) {
          t.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
        }
        function _initStorage$1(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i in options) {
              dbInfo[i] = typeof options[i] !== "string" ? options[i].toString() : options[i];
            }
          }
          var dbInfoPromise = new Promise$1(function(resolve, reject) {
            try {
              dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
            } catch (e) {
              return reject(e);
            }
            dbInfo.db.transaction(function(t) {
              createDbTable(t, dbInfo, function() {
                self2._dbInfo = dbInfo;
                resolve();
              }, function(t2, error) {
                reject(error);
              });
            }, reject);
          });
          dbInfo.serializer = localforageSerializer;
          return dbInfoPromise;
        }
        function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
          t.executeSql(sqlStatement, args, callback, function(t2, error) {
            if (error.code === error.SYNTAX_ERR) {
              t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t3, results) {
                if (!results.rows.length) {
                  createDbTable(t3, dbInfo, function() {
                    t3.executeSql(sqlStatement, args, callback, errorCallback);
                  }, errorCallback);
                } else {
                  errorCallback(t3, error);
                }
              }, errorCallback);
            } else {
              errorCallback(t2, error);
            }
          }, errorCallback);
        }
        function getItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t2, results) {
                  var result = results.rows.length ? results.rows.item(0).value : null;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  resolve(result);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$1(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t2, results) {
                  var rows = results.rows;
                  var length2 = rows.length;
                  for (var i = 0; i < length2; i++) {
                    var item = rows.item(i);
                    var result = item.value;
                    if (result) {
                      result = dbInfo.serializer.deserialize(result);
                    }
                    result = iterator(result, item.key, i + 1);
                    if (result !== void 0) {
                      resolve(result);
                      return;
                    }
                  }
                  resolve();
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function _setItem(key2, value, callback, retriesLeft) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              if (value === void 0) {
                value = null;
              }
              var originalValue = value;
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  dbInfo.db.transaction(function(t) {
                    tryExecuteSql(t, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                      resolve(originalValue);
                    }, function(t2, error2) {
                      reject(error2);
                    });
                  }, function(sqlError) {
                    if (sqlError.code === sqlError.QUOTA_ERR) {
                      if (retriesLeft > 0) {
                        resolve(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                        return;
                      }
                      reject(sqlError);
                    }
                  });
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$1(key2, value, callback) {
          return _setItem.apply(this, [key2, value, callback, 1]);
        }
        function removeItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                  resolve();
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                  resolve();
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t2, results) {
                  var result = results.rows.item(0).c;
                  resolve(result);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$1(n, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n + 1], function(t2, results) {
                  var result = results.rows.length ? results.rows.item(0).key : null;
                  resolve(result);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t2, results) {
                  var keys2 = [];
                  for (var i = 0; i < results.rows.length; i++) {
                    keys2.push(results.rows.item(i).key);
                  }
                  resolve(keys2);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getAllStoreNames(db) {
          return new Promise$1(function(resolve, reject) {
            db.transaction(function(t) {
              t.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t2, results) {
                var storeNames = [];
                for (var i = 0; i < results.rows.length; i++) {
                  storeNames.push(results.rows.item(i).name);
                }
                resolve({
                  db,
                  storeNames
                });
              }, function(t2, error) {
                reject(error);
              });
            }, function(sqlError) {
              reject(sqlError);
            });
          });
        }
        function dropInstance$1(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              var db;
              if (options.name === currentConfig.name) {
                db = self2._dbInfo.db;
              } else {
                db = openDatabase(options.name, "", "", 0);
              }
              if (!options.storeName) {
                resolve(getAllStoreNames(db));
              } else {
                resolve({
                  db,
                  storeNames: [options.storeName]
                });
              }
            }).then(function(operationInfo) {
              return new Promise$1(function(resolve, reject) {
                operationInfo.db.transaction(function(t) {
                  function dropTable(storeName) {
                    return new Promise$1(function(resolve2, reject2) {
                      t.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                        resolve2();
                      }, function(t2, error) {
                        reject2(error);
                      });
                    });
                  }
                  var operations = [];
                  for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                    operations.push(dropTable(operationInfo.storeNames[i]));
                  }
                  Promise$1.all(operations).then(function() {
                    resolve();
                  })["catch"](function(e) {
                    reject(e);
                  });
                }, function(sqlError) {
                  reject(sqlError);
                });
              });
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var webSQLStorage = {
          _driver: "webSQLStorage",
          _initStorage: _initStorage$1,
          _support: isWebSQLValid(),
          iterate: iterate$1,
          getItem: getItem$1,
          setItem: setItem$1,
          removeItem: removeItem$1,
          clear: clear$1,
          length: length$1,
          key: key$1,
          keys: keys$1,
          dropInstance: dropInstance$1
        };
        function isLocalStorageValid() {
          try {
            return typeof localStorage !== "undefined" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
            !!localStorage.setItem;
          } catch (e) {
            return false;
          }
        }
        function _getKeyPrefix(options, defaultConfig) {
          var keyPrefix = options.name + "/";
          if (options.storeName !== defaultConfig.storeName) {
            keyPrefix += options.storeName + "/";
          }
          return keyPrefix;
        }
        function checkIfLocalStorageThrows() {
          var localStorageTestKey = "_localforage_support_test";
          try {
            localStorage.setItem(localStorageTestKey, true);
            localStorage.removeItem(localStorageTestKey);
            return false;
          } catch (e) {
            return true;
          }
        }
        function _isLocalStorageUsable() {
          return !checkIfLocalStorageThrows() || localStorage.length > 0;
        }
        function _initStorage$2(options) {
          var self2 = this;
          var dbInfo = {};
          if (options) {
            for (var i in options) {
              dbInfo[i] = options[i];
            }
          }
          dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
          if (!_isLocalStorageUsable()) {
            return Promise$1.reject();
          }
          self2._dbInfo = dbInfo;
          dbInfo.serializer = localforageSerializer;
          return Promise$1.resolve();
        }
        function clear$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var keyPrefix = self2._dbInfo.keyPrefix;
            for (var i = localStorage.length - 1; i >= 0; i--) {
              var key2 = localStorage.key(i);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result = localStorage.getItem(dbInfo.keyPrefix + key2);
            if (result) {
              result = dbInfo.serializer.deserialize(result);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$2(iterator, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var keyPrefix = dbInfo.keyPrefix;
            var keyPrefixLength = keyPrefix.length;
            var length2 = localStorage.length;
            var iterationNumber = 1;
            for (var i = 0; i < length2; i++) {
              var key2 = localStorage.key(i);
              if (key2.indexOf(keyPrefix) !== 0) {
                continue;
              }
              var value = localStorage.getItem(key2);
              if (value) {
                value = dbInfo.serializer.deserialize(value);
              }
              value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
              if (value !== void 0) {
                return value;
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$2(n, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result;
            try {
              result = localStorage.key(n);
            } catch (error) {
              result = null;
            }
            if (result) {
              result = result.substring(dbInfo.keyPrefix.length);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var length2 = localStorage.length;
            var keys2 = [];
            for (var i = 0; i < length2; i++) {
              var itemKey = localStorage.key(i);
              if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys2.push(itemKey.substring(dbInfo.keyPrefix.length));
              }
            }
            return keys2;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$2(callback) {
          var self2 = this;
          var promise = self2.keys().then(function(keys2) {
            return keys2.length;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            localStorage.removeItem(dbInfo.keyPrefix + key2);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$2(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            return new Promise$1(function(resolve, reject) {
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  try {
                    localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                    resolve(originalValue);
                  } catch (e) {
                    if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                      reject(e);
                    }
                    reject(e);
                  }
                }
              });
            });
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance$2(options, callback) {
          callback = getCallback.apply(this, arguments);
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            var currentConfig = this.config();
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              if (!options.storeName) {
                resolve(options.name + "/");
              } else {
                resolve(_getKeyPrefix(options, self2._defaultConfig));
              }
            }).then(function(keyPrefix) {
              for (var i = localStorage.length - 1; i >= 0; i--) {
                var key2 = localStorage.key(i);
                if (key2.indexOf(keyPrefix) === 0) {
                  localStorage.removeItem(key2);
                }
              }
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var localStorageWrapper = {
          _driver: "localStorageWrapper",
          _initStorage: _initStorage$2,
          _support: isLocalStorageValid(),
          iterate: iterate$2,
          getItem: getItem$2,
          setItem: setItem$2,
          removeItem: removeItem$2,
          clear: clear$2,
          length: length$2,
          key: key$2,
          keys: keys$2,
          dropInstance: dropInstance$2
        };
        var sameValue = function sameValue2(x, y) {
          return x === y || typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
        };
        var includes = function includes2(array, searchElement) {
          var len = array.length;
          var i = 0;
          while (i < len) {
            if (sameValue(array[i], searchElement)) {
              return true;
            }
            i++;
          }
          return false;
        };
        var isArray = Array.isArray || function(arg) {
          return Object.prototype.toString.call(arg) === "[object Array]";
        };
        var DefinedDrivers = {};
        var DriverSupport = {};
        var DefaultDrivers = {
          INDEXEDDB: asyncStorage,
          WEBSQL: webSQLStorage,
          LOCALSTORAGE: localStorageWrapper
        };
        var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
        var OptionalDriverMethods = ["dropInstance"];
        var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
        var DefaultConfig = {
          description: "",
          driver: DefaultDriverOrder.slice(),
          name: "localforage",
          // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
          // we can use without a prompt.
          size: 4980736,
          storeName: "keyvaluepairs",
          version: 1
        };
        function callWhenReady(localForageInstance, libraryMethod) {
          localForageInstance[libraryMethod] = function() {
            var _args = arguments;
            return localForageInstance.ready().then(function() {
              return localForageInstance[libraryMethod].apply(localForageInstance, _args);
            });
          };
        }
        function extend() {
          for (var i = 1; i < arguments.length; i++) {
            var arg = arguments[i];
            if (arg) {
              for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                  if (isArray(arg[_key])) {
                    arguments[0][_key] = arg[_key].slice();
                  } else {
                    arguments[0][_key] = arg[_key];
                  }
                }
              }
            }
          }
          return arguments[0];
        }
        var LocalForage = function() {
          function LocalForage2(options) {
            _classCallCheck(this, LocalForage2);
            for (var driverTypeKey in DefaultDrivers) {
              if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;
                if (!DefinedDrivers[driverName]) {
                  this.defineDriver(driver);
                }
              }
            }
            this._defaultConfig = extend({}, DefaultConfig);
            this._config = extend({}, this._defaultConfig, options);
            this._driverSet = null;
            this._initDriver = null;
            this._ready = false;
            this._dbInfo = null;
            this._wrapLibraryMethodsWithReady();
            this.setDriver(this._config.driver)["catch"](function() {
            });
          }
          LocalForage2.prototype.config = function config(options) {
            if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
              if (this._ready) {
                return new Error("Can't call config() after localforage has been used.");
              }
              for (var i in options) {
                if (i === "storeName") {
                  options[i] = options[i].replace(/\W/g, "_");
                }
                if (i === "version" && typeof options[i] !== "number") {
                  return new Error("Database version must be a number.");
                }
                this._config[i] = options[i];
              }
              if ("driver" in options && options.driver) {
                return this.setDriver(this._config.driver);
              }
              return true;
            } else if (typeof options === "string") {
              return this._config[options];
            } else {
              return this._config;
            }
          };
          LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
            var promise = new Promise$1(function(resolve, reject) {
              try {
                var driverName = driverObject._driver;
                var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                if (!driverObject._driver) {
                  reject(complianceError);
                  return;
                }
                var driverMethods = LibraryMethods.concat("_initStorage");
                for (var i = 0, len = driverMethods.length; i < len; i++) {
                  var driverMethodName = driverMethods[i];
                  var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                  if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                    reject(complianceError);
                    return;
                  }
                }
                var configureMissingMethods = function configureMissingMethods2() {
                  var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                    return function() {
                      var error = new Error("Method " + methodName + " is not implemented by the current driver");
                      var promise2 = Promise$1.reject(error);
                      executeCallback(promise2, arguments[arguments.length - 1]);
                      return promise2;
                    };
                  };
                  for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                    var optionalDriverMethod = OptionalDriverMethods[_i];
                    if (!driverObject[optionalDriverMethod]) {
                      driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                    }
                  }
                };
                configureMissingMethods();
                var setDriverSupport = function setDriverSupport2(support) {
                  if (DefinedDrivers[driverName]) {
                    console.info("Redefining LocalForage driver: " + driverName);
                  }
                  DefinedDrivers[driverName] = driverObject;
                  DriverSupport[driverName] = support;
                  resolve();
                };
                if ("_support" in driverObject) {
                  if (driverObject._support && typeof driverObject._support === "function") {
                    driverObject._support().then(setDriverSupport, reject);
                  } else {
                    setDriverSupport(!!driverObject._support);
                  }
                } else {
                  setDriverSupport(true);
                }
              } catch (e) {
                reject(e);
              }
            });
            executeTwoCallbacks(promise, callback, errorCallback);
            return promise;
          };
          LocalForage2.prototype.driver = function driver() {
            return this._driver || null;
          };
          LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
            var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
            executeTwoCallbacks(getDriverPromise, callback, errorCallback);
            return getDriverPromise;
          };
          LocalForage2.prototype.getSerializer = function getSerializer(callback) {
            var serializerPromise = Promise$1.resolve(localforageSerializer);
            executeTwoCallbacks(serializerPromise, callback);
            return serializerPromise;
          };
          LocalForage2.prototype.ready = function ready(callback) {
            var self2 = this;
            var promise = self2._driverSet.then(function() {
              if (self2._ready === null) {
                self2._ready = self2._initDriver();
              }
              return self2._ready;
            });
            executeTwoCallbacks(promise, callback, callback);
            return promise;
          };
          LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
            var self2 = this;
            if (!isArray(drivers)) {
              drivers = [drivers];
            }
            var supportedDrivers = this._getSupportedDrivers(drivers);
            function setDriverToConfig() {
              self2._config.driver = self2.driver();
            }
            function extendSelfWithDriver(driver) {
              self2._extend(driver);
              setDriverToConfig();
              self2._ready = self2._initStorage(self2._config);
              return self2._ready;
            }
            function initDriver(supportedDrivers2) {
              return function() {
                var currentDriverIndex = 0;
                function driverPromiseLoop() {
                  while (currentDriverIndex < supportedDrivers2.length) {
                    var driverName = supportedDrivers2[currentDriverIndex];
                    currentDriverIndex++;
                    self2._dbInfo = null;
                    self2._ready = null;
                    return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                  }
                  setDriverToConfig();
                  var error = new Error("No available storage method found.");
                  self2._driverSet = Promise$1.reject(error);
                  return self2._driverSet;
                }
                return driverPromiseLoop();
              };
            }
            var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
              return Promise$1.resolve();
            }) : Promise$1.resolve();
            this._driverSet = oldDriverSetDone.then(function() {
              var driverName = supportedDrivers[0];
              self2._dbInfo = null;
              self2._ready = null;
              return self2.getDriver(driverName).then(function(driver) {
                self2._driver = driver._driver;
                setDriverToConfig();
                self2._wrapLibraryMethodsWithReady();
                self2._initDriver = initDriver(supportedDrivers);
              });
            })["catch"](function() {
              setDriverToConfig();
              var error = new Error("No available storage method found.");
              self2._driverSet = Promise$1.reject(error);
              return self2._driverSet;
            });
            executeTwoCallbacks(this._driverSet, callback, errorCallback);
            return this._driverSet;
          };
          LocalForage2.prototype.supports = function supports(driverName) {
            return !!DriverSupport[driverName];
          };
          LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
            extend(this, libraryMethodsAndProperties);
          };
          LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
            var supportedDrivers = [];
            for (var i = 0, len = drivers.length; i < len; i++) {
              var driverName = drivers[i];
              if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
              }
            }
            return supportedDrivers;
          };
          LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
            for (var i = 0, len = LibraryMethods.length; i < len; i++) {
              callWhenReady(this, LibraryMethods[i]);
            }
          };
          LocalForage2.prototype.createInstance = function createInstance(options) {
            return new LocalForage2(options);
          };
          return LocalForage2;
        }();
        var localforage_js = new LocalForage();
        module3.exports = localforage_js;
      }, { "3": 3 }] }, {}, [4])(4);
    });
  }
});

// node_modules/@seald-io/nedb/browser-version/lib/storage.browser.js
var require_storage_browser = __commonJS({
  "node_modules/@seald-io/nedb/browser-version/lib/storage.browser.js"(exports, module) {
    var localforage = require_localforage();
    var store = localforage.createInstance({
      name: "NeDB",
      storeName: "nedbdata"
    });
    var existsAsync = async (file) => {
      try {
        const value = await store.getItem(file);
        if (value !== null)
          return true;
        return false;
      } catch (error) {
        return false;
      }
    };
    var renameAsync = async (oldPath, newPath) => {
      try {
        const value = await store.getItem(oldPath);
        if (value === null)
          await store.removeItem(newPath);
        else {
          await store.setItem(newPath, value);
          await store.removeItem(oldPath);
        }
      } catch (err) {
        console.warn("An error happened while renaming, skip");
      }
    };
    var writeFileAsync = async (file, data, options) => {
      try {
        await store.setItem(file, data);
      } catch (error) {
        console.warn("An error happened while writing, skip");
      }
    };
    var appendFileAsync = async (filename, toAppend, options) => {
      try {
        const contents = await store.getItem(filename) || "";
        await store.setItem(filename, contents + toAppend);
      } catch (error) {
        console.warn("An error happened appending to file writing, skip");
      }
    };
    var readFileAsync = async (filename, options) => {
      try {
        return await store.getItem(filename) || "";
      } catch (error) {
        console.warn("An error happened while reading, skip");
        return "";
      }
    };
    var unlinkAsync = async (filename) => {
      try {
        await store.removeItem(filename);
      } catch (error) {
        console.warn("An error happened while unlinking, skip");
      }
    };
    var mkdirAsync = (path, options) => Promise.resolve();
    var ensureParentDirectoryExistsAsync = async (file, mode) => Promise.resolve();
    var ensureDatafileIntegrityAsync = (filename) => Promise.resolve();
    var crashSafeWriteFileLinesAsync = async (filename, lines) => {
      lines.push("");
      await writeFileAsync(filename, lines.join("\n"));
    };
    module.exports.existsAsync = existsAsync;
    module.exports.renameAsync = renameAsync;
    module.exports.writeFileAsync = writeFileAsync;
    module.exports.crashSafeWriteFileLinesAsync = crashSafeWriteFileLinesAsync;
    module.exports.appendFileAsync = appendFileAsync;
    module.exports.readFileAsync = readFileAsync;
    module.exports.unlinkAsync = unlinkAsync;
    module.exports.mkdirAsync = mkdirAsync;
    module.exports.ensureDatafileIntegrityAsync = ensureDatafileIntegrityAsync;
    module.exports.ensureParentDirectoryExistsAsync = ensureParentDirectoryExistsAsync;
  }
});

// node_modules/@seald-io/nedb/lib/persistence.js
var require_persistence = __commonJS({
  "node_modules/@seald-io/nedb/lib/persistence.js"(exports, module) {
    var { deprecate } = require_util();
    var byline = require_byline();
    var customUtils = require_customUtils();
    var Index = require_indexes();
    var model = require_model();
    var storage = require_storage_browser();
    var DEFAULT_DIR_MODE = 493;
    var DEFAULT_FILE_MODE = 420;
    var Persistence = class _Persistence {
      /**
       * Create a new Persistence object for database options.db
       * @param {Datastore} options.db
       * @param {Number} [options.corruptAlertThreshold] Optional, threshold after which an alert is thrown if too much data is corrupt
       * @param {serializationHook} [options.beforeDeserialization] Hook you can use to transform data after it was serialized and before it is written to disk.
       * @param {serializationHook} [options.afterSerialization] Inverse of `afterSerialization`.
       * @param {object} [options.modes] Modes to use for FS permissions. Will not work on Windows.
       * @param {number} [options.modes.fileMode=0o644] Mode to use for files.
       * @param {number} [options.modes.dirMode=0o755] Mode to use for directories.
       * @param {boolean} [options.testSerializationHooks=true] Whether to test the serialization hooks or not, might be CPU-intensive
       */
      constructor(options) {
        this.db = options.db;
        this.inMemoryOnly = this.db.inMemoryOnly;
        this.filename = this.db.filename;
        this.corruptAlertThreshold = options.corruptAlertThreshold !== void 0 ? options.corruptAlertThreshold : 0.1;
        this.modes = options.modes !== void 0 ? options.modes : { fileMode: DEFAULT_FILE_MODE, dirMode: DEFAULT_DIR_MODE };
        if (this.modes.fileMode === void 0)
          this.modes.fileMode = DEFAULT_FILE_MODE;
        if (this.modes.dirMode === void 0)
          this.modes.dirMode = DEFAULT_DIR_MODE;
        if (!this.inMemoryOnly && this.filename && this.filename.charAt(this.filename.length - 1) === "~")
          throw new Error("The datafile name can't end with a ~, which is reserved for crash safe backup files");
        if (options.afterSerialization && !options.beforeDeserialization)
          throw new Error("Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent dataloss");
        if (!options.afterSerialization && options.beforeDeserialization)
          throw new Error("Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent dataloss");
        this.afterSerialization = options.afterSerialization || ((s) => s);
        this.beforeDeserialization = options.beforeDeserialization || ((s) => s);
        if (options.testSerializationHooks === void 0 || options.testSerializationHooks) {
          for (let i = 1; i < 30; i += 1) {
            for (let j = 0; j < 10; j += 1) {
              const randomString = customUtils.uid(i);
              if (this.beforeDeserialization(this.afterSerialization(randomString)) !== randomString) {
                throw new Error("beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent dataloss");
              }
            }
          }
        }
      }
      /**
       * Internal version without using the {@link Datastore#executor} of {@link Datastore#compactDatafileAsync}, use it instead.
       * @return {Promise<void>}
       * @private
       */
      async persistCachedDatabaseAsync() {
        const lines = [];
        if (this.inMemoryOnly)
          return;
        this.db.getAllData().forEach((doc) => {
          lines.push(this.afterSerialization(model.serialize(doc)));
        });
        Object.keys(this.db.indexes).forEach((fieldName) => {
          if (fieldName !== "_id") {
            lines.push(this.afterSerialization(model.serialize({
              $$indexCreated: {
                fieldName: this.db.indexes[fieldName].fieldName,
                unique: this.db.indexes[fieldName].unique,
                sparse: this.db.indexes[fieldName].sparse
              }
            })));
          }
        });
        await storage.crashSafeWriteFileLinesAsync(this.filename, lines, this.modes);
        this.db.emit("compaction.done");
      }
      /**
       * @see Datastore#compactDatafile
       * @deprecated
       * @param {NoParamCallback} [callback = () => {}]
       * @see Persistence#compactDatafileAsync
       */
      compactDatafile(callback) {
        deprecate((_callback) => this.db.compactDatafile(_callback), "@seald-io/nedb: calling Datastore#persistence#compactDatafile is deprecated, please use Datastore#compactDatafile, it will be removed in the next major version.")(callback);
      }
      /**
       * @see Datastore#setAutocompactionInterval
       * @deprecated
       */
      setAutocompactionInterval(interval) {
        deprecate((_interval) => this.db.setAutocompactionInterval(_interval), "@seald-io/nedb: calling Datastore#persistence#setAutocompactionInterval is deprecated, please use Datastore#setAutocompactionInterval, it will be removed in the next major version.")(interval);
      }
      /**
       * @see Datastore#stopAutocompaction
       * @deprecated
       */
      stopAutocompaction() {
        deprecate(() => this.db.stopAutocompaction(), "@seald-io/nedb: calling Datastore#persistence#stopAutocompaction is deprecated, please use Datastore#stopAutocompaction, it will be removed in the next major version.")();
      }
      /**
       * Persist new state for the given newDocs (can be insertion, update or removal)
       * Use an append-only format
       *
       * Do not use directly, it should only used by a {@link Datastore} instance.
       * @param {document[]} newDocs Can be empty if no doc was updated/removed
       * @return {Promise}
       * @private
       */
      async persistNewStateAsync(newDocs) {
        let toPersist = "";
        if (this.inMemoryOnly)
          return;
        newDocs.forEach((doc) => {
          toPersist += this.afterSerialization(model.serialize(doc)) + "\n";
        });
        if (toPersist.length === 0)
          return;
        await storage.appendFileAsync(this.filename, toPersist, { encoding: "utf8", mode: this.modes.fileMode });
      }
      /**
       * @typedef rawIndex
       * @property {string} fieldName
       * @property {boolean} [unique]
       * @property {boolean} [sparse]
       */
      /**
       * From a database's raw data, return the corresponding machine understandable collection.
       *
       * Do not use directly, it should only used by a {@link Datastore} instance.
       * @param {string} rawData database file
       * @return {{data: document[], indexes: Object.<string, rawIndex>}}
       * @private
       */
      treatRawData(rawData) {
        const data = rawData.split("\n");
        const dataById = {};
        const indexes = {};
        let dataLength = data.length;
        let corruptItems = 0;
        for (const datum of data) {
          if (datum === "") {
            dataLength--;
            continue;
          }
          try {
            const doc = model.deserialize(this.beforeDeserialization(datum));
            if (doc._id) {
              if (doc.$$deleted === true)
                delete dataById[doc._id];
              else
                dataById[doc._id] = doc;
            } else if (doc.$$indexCreated && doc.$$indexCreated.fieldName != null)
              indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;
            else if (typeof doc.$$indexRemoved === "string")
              delete indexes[doc.$$indexRemoved];
          } catch (e) {
            corruptItems += 1;
          }
        }
        if (dataLength > 0) {
          const corruptionRate = corruptItems / dataLength;
          if (corruptionRate > this.corruptAlertThreshold) {
            const error = new Error(`${Math.floor(100 * corruptionRate)}% of the data file is corrupt, more than given corruptAlertThreshold (${Math.floor(100 * this.corruptAlertThreshold)}%). Cautiously refusing to start NeDB to prevent dataloss.`);
            error.corruptionRate = corruptionRate;
            error.corruptItems = corruptItems;
            error.dataLength = dataLength;
            throw error;
          }
        }
        const tdata = Object.values(dataById);
        return { data: tdata, indexes };
      }
      /**
       * From a database's raw data stream, return the corresponding machine understandable collection
       * Is only used by a {@link Datastore} instance.
       *
       * Is only used in the Node.js version, since [React-Native]{@link module:storageReactNative} &
       * [browser]{@link module:storageBrowser} storage modules don't provide an equivalent of
       * {@link module:storage.readFileStream}.
       *
       * Do not use directly, it should only used by a {@link Datastore} instance.
       * @param {Readable} rawStream
       * @return {Promise<{data: document[], indexes: Object.<string, rawIndex>}>}
       * @async
       * @private
       */
      treatRawStreamAsync(rawStream) {
        return new Promise((resolve, reject) => {
          const dataById = {};
          const indexes = {};
          let corruptItems = 0;
          const lineStream = byline(rawStream);
          let dataLength = 0;
          lineStream.on("data", (line) => {
            if (line === "")
              return;
            try {
              const doc = model.deserialize(this.beforeDeserialization(line));
              if (doc._id) {
                if (doc.$$deleted === true)
                  delete dataById[doc._id];
                else
                  dataById[doc._id] = doc;
              } else if (doc.$$indexCreated && doc.$$indexCreated.fieldName != null)
                indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;
              else if (typeof doc.$$indexRemoved === "string")
                delete indexes[doc.$$indexRemoved];
            } catch (e) {
              corruptItems += 1;
            }
            dataLength++;
          });
          lineStream.on("end", () => {
            if (dataLength > 0) {
              const corruptionRate = corruptItems / dataLength;
              if (corruptionRate > this.corruptAlertThreshold) {
                const error = new Error(`${Math.floor(100 * corruptionRate)}% of the data file is corrupt, more than given corruptAlertThreshold (${Math.floor(100 * this.corruptAlertThreshold)}%). Cautiously refusing to start NeDB to prevent dataloss.`);
                error.corruptionRate = corruptionRate;
                error.corruptItems = corruptItems;
                error.dataLength = dataLength;
                reject(error, null);
                return;
              }
            }
            const data = Object.values(dataById);
            resolve({ data, indexes });
          });
          lineStream.on("error", function(err) {
            reject(err, null);
          });
        });
      }
      /**
       * Load the database
       * 1) Create all indexes
       * 2) Insert all data
       * 3) Compact the database
       *
       * This means pulling data out of the data file or creating it if it doesn't exist
       * Also, all data is persisted right away, which has the effect of compacting the database file
       * This operation is very quick at startup for a big collection (60ms for ~10k docs)
       *
       * Do not use directly as it does not use the [Executor]{@link Datastore.executor}, use {@link Datastore#loadDatabaseAsync} instead.
       * @return {Promise<void>}
       * @private
       */
      async loadDatabaseAsync() {
        this.db._resetIndexes();
        if (this.inMemoryOnly)
          return;
        await _Persistence.ensureParentDirectoryExistsAsync(this.filename, this.modes.dirMode);
        await storage.ensureDatafileIntegrityAsync(this.filename, this.modes.fileMode);
        let treatedData;
        if (storage.readFileStream) {
          const fileStream = storage.readFileStream(this.filename, { encoding: "utf8", mode: this.modes.fileMode });
          treatedData = await this.treatRawStreamAsync(fileStream);
        } else {
          const rawData = await storage.readFileAsync(this.filename, { encoding: "utf8", mode: this.modes.fileMode });
          treatedData = this.treatRawData(rawData);
        }
        Object.keys(treatedData.indexes).forEach((key) => {
          this.db.indexes[key] = new Index(treatedData.indexes[key]);
        });
        try {
          this.db._resetIndexes(treatedData.data);
        } catch (e) {
          this.db._resetIndexes();
          throw e;
        }
        await this.db.persistence.persistCachedDatabaseAsync();
        this.db.executor.processBuffer();
      }
      /**
       * See {@link Datastore#dropDatabaseAsync}. This function uses {@link Datastore#executor} internally. Decorating this
       * function with an {@link Executor#pushAsync} will result in a deadlock.
       * @return {Promise<void>}
       * @private
       * @see Datastore#dropDatabaseAsync
       */
      async dropDatabaseAsync() {
        this.db.stopAutocompaction();
        this.db.executor.ready = false;
        this.db.executor.resetBuffer();
        await this.db.executor.queue.guardian;
        this.db.indexes = {};
        this.db.indexes._id = new Index({ fieldName: "_id", unique: true });
        this.db.ttlIndexes = {};
        if (!this.db.inMemoryOnly) {
          await this.db.executor.pushAsync(async () => {
            if (await storage.existsAsync(this.filename))
              await storage.unlinkAsync(this.filename);
          }, true);
        }
      }
      /**
       * Check if a directory stat and create it on the fly if it is not the case.
       * @param {string} dir
       * @param {number} [mode=0o777]
       * @return {Promise<void>}
       * @private
       */
      static async ensureParentDirectoryExistsAsync(dir, mode = DEFAULT_DIR_MODE) {
        return storage.ensureParentDirectoryExistsAsync(dir, mode);
      }
    };
    module.exports = Persistence;
  }
});

// node_modules/@seald-io/nedb/lib/datastore.js
var require_datastore = __commonJS({
  "node_modules/@seald-io/nedb/lib/datastore.js"(exports, module) {
    var { EventEmitter } = require_events();
    var { callbackify, deprecate } = require_util();
    var Cursor = require_cursor();
    var customUtils = require_customUtils();
    var Executor = require_executor();
    var Index = require_indexes();
    var model = require_model();
    var Persistence = require_persistence();
    var { isDate, pick, filterIndexNames } = require_utils();
    var Datastore = class extends EventEmitter {
      /**
       * Create a new collection, either persistent or in-memory.
       *
       * If you use a persistent datastore without the `autoload` option, you need to call {@link Datastore#loadDatabase} or
       * {@link Datastore#loadDatabaseAsync} manually. This function fetches the data from datafile and prepares the database.
       * **Don't forget it!** If you use a persistent datastore, no command (insert, find, update, remove) will be executed
       * before it is called, so make sure to call it yourself or use the `autoload` option.
       *
       * Also, if loading fails, all commands registered to the {@link Datastore#executor} afterwards will not be executed.
       * They will be registered and executed, in sequence, only after a successful loading.
       *
       * @param {object|string} options Can be an object or a string. If options is a string, the behavior is the same as in
       * v0.6: it will be interpreted as `options.filename`. **Giving a string is deprecated, and will be removed in the
       * next major version.**
       * @param {string} [options.filename = null] Path to the file where the data is persisted. If left blank, the datastore is
       * automatically considered in-memory only. It cannot end with a `~` which is used in the temporary files NeDB uses to
       * perform crash-safe writes. Not used if `options.inMemoryOnly` is `true`.
       * @param {boolean} [options.inMemoryOnly = false] If set to true, no data will be written in storage. This option has
       * priority over `options.filename`.
       * @param {object} [options.modes] Permissions to use for FS. Only used for Node.js storage module. Will not work on Windows.
       * @param {number} [options.modes.fileMode = 0o644] Permissions to use for database files
       * @param {number} [options.modes.dirMode = 0o755] Permissions to use for database directories
       * @param {boolean} [options.timestampData = false] If set to true, createdAt and updatedAt will be created and
       * populated automatically (if not specified by user)
       * @param {boolean} [options.autoload = false] If used, the database will automatically be loaded from the datafile
       * upon creation (you don't need to call `loadDatabase`). Any command issued before load is finished is buffered and
       * will be executed when load is done. When autoloading is done, you can either use the `onload` callback, or you can
       * use `this.autoloadPromise` which resolves (or rejects) when autloading is done.
       * @param {NoParamCallback} [options.onload] If you use autoloading, this is the handler called after the `loadDatabase`. It
       * takes one `error` argument. If you use autoloading without specifying this handler, and an error happens during
       * load, an error will be thrown.
       * @param {serializationHook} [options.beforeDeserialization] Hook you can use to transform data after it was serialized and
       * before it is written to disk. Can be used for example to encrypt data before writing database to disk. This
       * function takes a string as parameter (one line of an NeDB data file) and outputs the transformed string, **which
       * must absolutely not contain a `\n` character** (or data will be lost).
       * @param {serializationHook} [options.afterSerialization] Inverse of `afterSerialization`. Make sure to include both and not
       * just one, or you risk data loss. For the same reason, make sure both functions are inverses of one another. Some
       * failsafe mechanisms are in place to prevent data loss if you misuse the serialization hooks: NeDB checks that never
       * one is declared without the other, and checks that they are reverse of one another by testing on random strings of
       * various lengths. In addition, if too much data is detected as corrupt, NeDB will refuse to start as it could mean
       * you're not using the deserialization hook corresponding to the serialization hook used before.
       * @param {number} [options.corruptAlertThreshold = 0.1] Between 0 and 1, defaults to 10%. NeDB will refuse to start
       * if more than this percentage of the datafile is corrupt. 0 means you don't tolerate any corruption, 1 means you
       * don't care.
       * @param {compareStrings} [options.compareStrings] If specified, it overrides default string comparison which is not
       * well adapted to non-US characters in particular accented letters. Native `localCompare` will most of the time be
       * the right choice.
       * @param {boolean} [options.testSerializationHooks=true] Whether to test the serialization hooks or not,
       * might be CPU-intensive
       */
      constructor(options) {
        super();
        let filename;
        if (typeof options === "string") {
          deprecate(() => {
            filename = options;
            this.inMemoryOnly = false;
          }, "@seald-io/nedb: Giving a string to the Datastore constructor is deprecated and will be removed in the next major version. Please use an options object with an argument 'filename'.")();
        } else {
          options = options || {};
          filename = options.filename;
          this.inMemoryOnly = options.inMemoryOnly || false;
          this.autoload = options.autoload || false;
          this.timestampData = options.timestampData || false;
        }
        if (!filename || typeof filename !== "string" || filename.length === 0) {
          this.filename = null;
          this.inMemoryOnly = true;
        } else {
          this.filename = filename;
        }
        this.compareStrings = options.compareStrings;
        this.persistence = new Persistence({
          db: this,
          afterSerialization: options.afterSerialization,
          beforeDeserialization: options.beforeDeserialization,
          corruptAlertThreshold: options.corruptAlertThreshold,
          modes: options.modes,
          testSerializationHooks: options.testSerializationHooks
        });
        this.executor = new Executor();
        if (this.inMemoryOnly)
          this.executor.ready = true;
        this.indexes = {};
        this.indexes._id = new Index({ fieldName: "_id", unique: true });
        this.ttlIndexes = {};
        if (this.autoload) {
          this.autoloadPromise = this.loadDatabaseAsync();
          this.autoloadPromise.then(() => {
            if (options.onload)
              options.onload();
          }, (err) => {
            if (options.onload)
              options.onload(err);
            else
              throw err;
          });
        } else
          this.autoloadPromise = null;
        this._autocompactionIntervalId = null;
      }
      /**
       * Queue a compaction/rewrite of the datafile.
       * It works by rewriting the database file, and compacts it since the cache always contains only the number of
       * documents in the collection while the data file is append-only so it may grow larger.
       *
       * @async
       */
      compactDatafileAsync() {
        return this.executor.pushAsync(() => this.persistence.persistCachedDatabaseAsync());
      }
      /**
       * Callback version of {@link Datastore#compactDatafileAsync}.
       * @param {NoParamCallback} [callback = () => {}]
       * @see Datastore#compactDatafileAsync
       */
      compactDatafile(callback) {
        const promise = this.compactDatafileAsync();
        if (typeof callback === "function")
          callbackify(() => promise)(callback);
      }
      /**
       * Set automatic compaction every `interval` ms
       * @param {Number} interval in milliseconds, with an enforced minimum of 5000 milliseconds
       */
      setAutocompactionInterval(interval) {
        const minInterval = 5e3;
        if (Number.isNaN(Number(interval)))
          throw new Error("Interval must be a non-NaN number");
        const realInterval = Math.max(Number(interval), minInterval);
        this.stopAutocompaction();
        this._autocompactionIntervalId = setInterval(() => {
          this.compactDatafile();
        }, realInterval);
      }
      /**
       * Stop autocompaction (do nothing if automatic compaction was not running)
       */
      stopAutocompaction() {
        if (this._autocompactionIntervalId) {
          clearInterval(this._autocompactionIntervalId);
          this._autocompactionIntervalId = null;
        }
      }
      /**
       * Callback version of {@link Datastore#loadDatabaseAsync}.
       * @param {NoParamCallback} [callback]
       * @see Datastore#loadDatabaseAsync
       */
      loadDatabase(callback) {
        const promise = this.loadDatabaseAsync();
        if (typeof callback === "function")
          callbackify(() => promise)(callback);
      }
      /**
       * Stops auto-compaction, finishes all queued operations, drops the database both in memory and in storage.
       * **WARNING**: it is not recommended re-using an instance of NeDB if its database has been dropped, it is
       * preferable to instantiate a new one.
       * @async
       * @return {Promise}
       */
      dropDatabaseAsync() {
        return this.persistence.dropDatabaseAsync();
      }
      /**
       * Callback version of {@link Datastore#dropDatabaseAsync}.
       * @param {NoParamCallback} [callback]
       * @see Datastore#dropDatabaseAsync
       */
      dropDatabase(callback) {
        const promise = this.dropDatabaseAsync();
        if (typeof callback === "function")
          callbackify(() => promise)(callback);
      }
      /**
       * Load the database from the datafile, and trigger the execution of buffered commands if any.
       * @async
       * @return {Promise}
       */
      loadDatabaseAsync() {
        return this.executor.pushAsync(() => this.persistence.loadDatabaseAsync(), true);
      }
      /**
       * Get an array of all the data in the database.
       * @return {document[]}
       */
      getAllData() {
        return this.indexes._id.getAll();
      }
      /**
       * Reset all currently defined indexes.
       * @param {?document|?document[]} [newData]
       * @private
       */
      _resetIndexes(newData) {
        for (const index of Object.values(this.indexes)) {
          index.reset(newData);
        }
      }
      /**
       * Callback version of {@link Datastore#ensureIndex}.
       * @param {object} options
       * @param {string|string[]} options.fieldName
       * @param {boolean} [options.unique = false]
       * @param {boolean} [options.sparse = false]
       * @param {number} [options.expireAfterSeconds]
       * @param {NoParamCallback} [callback]
       * @see Datastore#ensureIndex
       */
      ensureIndex(options = {}, callback) {
        const promise = this.ensureIndexAsync(options);
        if (typeof callback === "function")
          callbackify(() => promise)(callback);
      }
      /**
       * Ensure an index is kept for this field. Same parameters as lib/indexes
       * This function acts synchronously on the indexes, however the persistence of the indexes is deferred with the
       * executor.
       * @param {object} options
       * @param {string|string[]} options.fieldName Name of the field to index. Use the dot notation to index a field in a nested
       * document. For a compound index, use an array of field names. Using a comma in a field name is not permitted.
       * @param {boolean} [options.unique = false] Enforce field uniqueness. Note that a unique index will raise an error
       * if you try to index two documents for which the field is not defined.
       * @param {boolean} [options.sparse = false] Don't index documents for which the field is not defined. Use this option
       * along with "unique" if you want to accept multiple documents for which it is not defined.
       * @param {number} [options.expireAfterSeconds] - If set, the created index is a TTL (time to live) index, that will
       * automatically remove documents when the system date becomes larger than the date on the indexed field plus
       * `expireAfterSeconds`. Documents where the indexed field is not specified or not a `Date` object are ignored.
       * @return {Promise<void>}
       */
      async ensureIndexAsync(options = {}) {
        if (!options.fieldName) {
          const err = new Error("Cannot create an index without a fieldName");
          err.missingFieldName = true;
          throw err;
        }
        const _fields = [].concat(options.fieldName).sort();
        if (_fields.some((field) => field.includes(","))) {
          throw new Error("Cannot use comma in index fieldName");
        }
        const _options = {
          ...options,
          fieldName: _fields.join(",")
        };
        if (this.indexes[_options.fieldName])
          return;
        this.indexes[_options.fieldName] = new Index(_options);
        if (options.expireAfterSeconds !== void 0)
          this.ttlIndexes[_options.fieldName] = _options.expireAfterSeconds;
        try {
          this.indexes[_options.fieldName].insert(this.getAllData());
        } catch (e) {
          delete this.indexes[_options.fieldName];
          throw e;
        }
        await this.executor.pushAsync(() => this.persistence.persistNewStateAsync([{ $$indexCreated: _options }]), true);
      }
      /**
       * Callback version of {@link Datastore#removeIndexAsync}.
       * @param {string} fieldName
       * @param {NoParamCallback} [callback]
       * @see Datastore#removeIndexAsync
       */
      removeIndex(fieldName, callback = () => {
      }) {
        const promise = this.removeIndexAsync(fieldName);
        callbackify(() => promise)(callback);
      }
      /**
       * Remove an index.
       * @param {string} fieldName Field name of the index to remove. Use the dot notation to remove an index referring to a
       * field in a nested document.
       * @return {Promise<void>}
       * @see Datastore#removeIndex
       */
      async removeIndexAsync(fieldName) {
        delete this.indexes[fieldName];
        await this.executor.pushAsync(() => this.persistence.persistNewStateAsync([{ $$indexRemoved: fieldName }]), true);
      }
      /**
       * Add one or several document(s) to all indexes.
       *
       * This is an internal function.
       * @param {document} doc
       * @private
       */
      _addToIndexes(doc) {
        let failingIndex;
        let error;
        const keys = Object.keys(this.indexes);
        for (let i = 0; i < keys.length; i += 1) {
          try {
            this.indexes[keys[i]].insert(doc);
          } catch (e) {
            failingIndex = i;
            error = e;
            break;
          }
        }
        if (error) {
          for (let i = 0; i < failingIndex; i += 1) {
            this.indexes[keys[i]].remove(doc);
          }
          throw error;
        }
      }
      /**
       * Remove one or several document(s) from all indexes.
       *
       * This is an internal function.
       * @param {document} doc
       * @private
       */
      _removeFromIndexes(doc) {
        for (const index of Object.values(this.indexes)) {
          index.remove(doc);
        }
      }
      /**
       * Update one or several documents in all indexes.
       *
       * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs.
       *
       * If one update violates a constraint, all changes are rolled back.
       *
       * This is an internal function.
       * @param {document|Array.<{oldDoc: document, newDoc: document}>} oldDoc Document to update, or an `Array` of
       * `{oldDoc, newDoc}` pairs.
       * @param {document} [newDoc] Document to replace the oldDoc with. If the first argument is an `Array` of
       * `{oldDoc, newDoc}` pairs, this second argument is ignored.
       * @private
       */
      _updateIndexes(oldDoc, newDoc) {
        let failingIndex;
        let error;
        const keys = Object.keys(this.indexes);
        for (let i = 0; i < keys.length; i += 1) {
          try {
            this.indexes[keys[i]].update(oldDoc, newDoc);
          } catch (e) {
            failingIndex = i;
            error = e;
            break;
          }
        }
        if (error) {
          for (let i = 0; i < failingIndex; i += 1) {
            this.indexes[keys[i]].revertUpdate(oldDoc, newDoc);
          }
          throw error;
        }
      }
      /**
       * Get all candidate documents matching the query, regardless of their expiry status.
       * @param {query} query
       * @return {document[]}
       *
       * @private
       */
      _getRawCandidates(query) {
        const indexNames = Object.keys(this.indexes);
        let usableQuery;
        usableQuery = Object.entries(query).filter(filterIndexNames(indexNames)).pop();
        if (usableQuery)
          return this.indexes[usableQuery[0]].getMatching(usableQuery[1]);
        const compoundQueryKeys = indexNames.filter((indexName) => indexName.indexOf(",") !== -1).map((indexName) => indexName.split(",")).filter(
          (subIndexNames) => Object.entries(query).filter(filterIndexNames(subIndexNames)).length === subIndexNames.length
        );
        if (compoundQueryKeys.length > 0)
          return this.indexes[compoundQueryKeys[0]].getMatching(pick(query, compoundQueryKeys[0]));
        usableQuery = Object.entries(query).filter(
          ([k, v]) => !!(query[k] && Object.prototype.hasOwnProperty.call(query[k], "$in")) && indexNames.includes(k)
        ).pop();
        if (usableQuery)
          return this.indexes[usableQuery[0]].getMatching(usableQuery[1].$in);
        usableQuery = Object.entries(query).filter(
          ([k, v]) => !!(query[k] && (Object.prototype.hasOwnProperty.call(query[k], "$lt") || Object.prototype.hasOwnProperty.call(query[k], "$lte") || Object.prototype.hasOwnProperty.call(query[k], "$gt") || Object.prototype.hasOwnProperty.call(query[k], "$gte"))) && indexNames.includes(k)
        ).pop();
        if (usableQuery)
          return this.indexes[usableQuery[0]].getBetweenBounds(usableQuery[1]);
        return this.getAllData();
      }
      /**
       * Return the list of candidates for a given query
       * Crude implementation for now, we return the candidates given by the first usable index if any
       * We try the following query types, in this order: basic match, $in match, comparison match
       * One way to make it better would be to enable the use of multiple indexes if the first usable index
       * returns too much data. I may do it in the future.
       *
       * Returned candidates will be scanned to find and remove all expired documents
       *
       * This is an internal function.
       * @param {query} query
       * @param {boolean} [dontExpireStaleDocs = false] If true don't remove stale docs. Useful for the remove function
       * which shouldn't be impacted by expirations.
       * @return {Promise<document[]>} candidates
       * @private
       */
      async _getCandidatesAsync(query, dontExpireStaleDocs = false) {
        const validDocs = [];
        const docs = this._getRawCandidates(query);
        if (!dontExpireStaleDocs) {
          const expiredDocsIds = [];
          const ttlIndexesFieldNames = Object.keys(this.ttlIndexes);
          docs.forEach((doc) => {
            if (ttlIndexesFieldNames.every((i) => !(doc[i] !== void 0 && isDate(doc[i]) && Date.now() > doc[i].getTime() + this.ttlIndexes[i] * 1e3)))
              validDocs.push(doc);
            else
              expiredDocsIds.push(doc._id);
          });
          for (const _id of expiredDocsIds) {
            await this._removeAsync({ _id }, {});
          }
        } else
          validDocs.push(...docs);
        return validDocs;
      }
      /**
       * Insert a new document
       * This is an internal function, use {@link Datastore#insertAsync} which has the same signature.
       * @param {document|document[]} newDoc
       * @return {Promise<document|document[]>}
       * @private
       */
      async _insertAsync(newDoc) {
        const preparedDoc = this._prepareDocumentForInsertion(newDoc);
        this._insertInCache(preparedDoc);
        await this.persistence.persistNewStateAsync(Array.isArray(preparedDoc) ? preparedDoc : [preparedDoc]);
        return model.deepCopy(preparedDoc);
      }
      /**
       * Create a new _id that's not already in use
       * @return {string} id
       * @private
       */
      _createNewId() {
        let attemptId = customUtils.uid(16);
        if (this.indexes._id.getMatching(attemptId).length > 0)
          attemptId = this._createNewId();
        return attemptId;
      }
      /**
       * Prepare a document (or array of documents) to be inserted in a database
       * Meaning adds _id and timestamps if necessary on a copy of newDoc to avoid any side effect on user input
       * @param {document|document[]} newDoc document, or Array of documents, to prepare
       * @return {document|document[]} prepared document, or Array of prepared documents
       * @private
       */
      _prepareDocumentForInsertion(newDoc) {
        let preparedDoc;
        if (Array.isArray(newDoc)) {
          preparedDoc = [];
          newDoc.forEach((doc) => {
            preparedDoc.push(this._prepareDocumentForInsertion(doc));
          });
        } else {
          preparedDoc = model.deepCopy(newDoc);
          if (preparedDoc._id === void 0)
            preparedDoc._id = this._createNewId();
          const now = /* @__PURE__ */ new Date();
          if (this.timestampData && preparedDoc.createdAt === void 0)
            preparedDoc.createdAt = now;
          if (this.timestampData && preparedDoc.updatedAt === void 0)
            preparedDoc.updatedAt = now;
          model.checkObject(preparedDoc);
        }
        return preparedDoc;
      }
      /**
       * If newDoc is an array of documents, this will insert all documents in the cache
       * @param {document|document[]} preparedDoc
       * @private
       */
      _insertInCache(preparedDoc) {
        if (Array.isArray(preparedDoc))
          this._insertMultipleDocsInCache(preparedDoc);
        else
          this._addToIndexes(preparedDoc);
      }
      /**
       * If one insertion fails (e.g. because of a unique constraint), roll back all previous
       * inserts and throws the error
       * @param {document[]} preparedDocs
       * @private
       */
      _insertMultipleDocsInCache(preparedDocs) {
        let failingIndex;
        let error;
        for (let i = 0; i < preparedDocs.length; i += 1) {
          try {
            this._addToIndexes(preparedDocs[i]);
          } catch (e) {
            error = e;
            failingIndex = i;
            break;
          }
        }
        if (error) {
          for (let i = 0; i < failingIndex; i += 1) {
            this._removeFromIndexes(preparedDocs[i]);
          }
          throw error;
        }
      }
      /**
       * Callback version of {@link Datastore#insertAsync}.
       * @param {document|document[]} newDoc
       * @param {SingleDocumentCallback|MultipleDocumentsCallback} [callback]
       * @see Datastore#insertAsync
       */
      insert(newDoc, callback) {
        const promise = this.insertAsync(newDoc);
        if (typeof callback === "function")
          callbackify(() => promise)(callback);
      }
      /**
       * Insert a new document, or new documents.
       * @param {document|document[]} newDoc Document or array of documents to insert.
       * @return {Promise<document|document[]>} The document(s) inserted.
       * @async
       */
      insertAsync(newDoc) {
        return this.executor.pushAsync(() => this._insertAsync(newDoc));
      }
      /**
       * Callback for {@link Datastore#countCallback}.
       * @callback Datastore~countCallback
       * @param {?Error} err
       * @param {?number} count
       */
      /**
       * Callback-version of {@link Datastore#countAsync}.
       * @param {query} query
       * @param {Datastore~countCallback} [callback]
       * @return {Cursor<number>|undefined}
       * @see Datastore#countAsync
       */
      count(query, callback) {
        const cursor = this.countAsync(query);
        if (typeof callback === "function")
          callbackify(cursor.execAsync.bind(cursor))(callback);
        else
          return cursor;
      }
      /**
       * Count all documents matching the query.
       * @param {query} query MongoDB-style query
       * @return {Cursor<number>} count
       * @async
       */
      countAsync(query) {
        return new Cursor(this, query, (docs) => docs.length);
      }
      /**
       * Callback version of {@link Datastore#findAsync}.
       * @param {query} query
       * @param {projection|MultipleDocumentsCallback} [projection = {}]
       * @param {MultipleDocumentsCallback} [callback]
       * @return {Cursor<document[]>|undefined}
       * @see Datastore#findAsync
       */
      find(query, projection, callback) {
        if (arguments.length === 1) {
          projection = {};
        } else if (arguments.length === 2) {
          if (typeof projection === "function") {
            callback = projection;
            projection = {};
          }
        }
        const cursor = this.findAsync(query, projection);
        if (typeof callback === "function")
          callbackify(cursor.execAsync.bind(cursor))(callback);
        else
          return cursor;
      }
      /**
       * Find all documents matching the query.
       * We return the {@link Cursor} that the user can either `await` directly or use to can {@link Cursor#limit} or
       * {@link Cursor#skip} before.
       * @param {query} query MongoDB-style query
       * @param {projection} [projection = {}] MongoDB-style projection
       * @return {Cursor<document[]>}
       * @async
       */
      findAsync(query, projection = {}) {
        const cursor = new Cursor(this, query, (docs) => docs.map((doc) => model.deepCopy(doc)));
        cursor.projection(projection);
        return cursor;
      }
      /**
       * @callback Datastore~findOneCallback
       * @param {?Error} err
       * @param {document} doc
       */
      /**
       * Callback version of {@link Datastore#findOneAsync}.
       * @param {query} query
       * @param {projection|SingleDocumentCallback} [projection = {}]
       * @param {SingleDocumentCallback} [callback]
       * @return {Cursor<document>|undefined}
       * @see Datastore#findOneAsync
       */
      findOne(query, projection, callback) {
        if (arguments.length === 1) {
          projection = {};
        } else if (arguments.length === 2) {
          if (typeof projection === "function") {
            callback = projection;
            projection = {};
          }
        }
        const cursor = this.findOneAsync(query, projection);
        if (typeof callback === "function")
          callbackify(cursor.execAsync.bind(cursor))(callback);
        else
          return cursor;
      }
      /**
       * Find one document matching the query.
       * We return the {@link Cursor} that the user can either `await` directly or use to can {@link Cursor#skip} before.
       * @param {query} query MongoDB-style query
       * @param {projection} projection MongoDB-style projection
       * @return {Cursor<document>}
       */
      findOneAsync(query, projection = {}) {
        const cursor = new Cursor(this, query, (docs) => docs.length === 1 ? model.deepCopy(docs[0]) : null);
        cursor.projection(projection).limit(1);
        return cursor;
      }
      /**
       * See {@link Datastore#updateAsync} return type for the definition of the callback parameters.
       *
       * **WARNING:** Prior to 3.0.0, `upsert` was either `true` of falsy (but not `false`), it is now always a boolean.
       * `affectedDocuments` could be `undefined` when `returnUpdatedDocs` was `false`, it is now `null` in these cases.
       *
       * **WARNING:** Prior to 1.8.0, the `upsert` argument was not given, it was impossible for the developer to determine
       * during a `{ multi: false, returnUpdatedDocs: true, upsert: true }` update if it inserted a document or just updated
       * it.
       *
       * @callback Datastore~updateCallback
       * @param {?Error} err
       * @param {number} numAffected
       * @param {?document[]|?document} affectedDocuments
       * @param {boolean} upsert
       * @see {Datastore#updateAsync}
       */
      /**
       * Version without the using {@link Datastore~executor} of {@link Datastore#updateAsync}, use it instead.
       *
       * @param {query} query
       * @param {document|update} update
       * @param {Object} options
       * @param {boolean} [options.multi = false]
       * @param {boolean} [options.upsert = false]
       * @param {boolean} [options.returnUpdatedDocs = false]
       * @return {Promise<{numAffected: number, affectedDocuments: document[]|document|null, upsert: boolean}>}
       * @private
       * @see Datastore#updateAsync
       */
      async _updateAsync(query, update, options) {
        const multi = options.multi !== void 0 ? options.multi : false;
        const upsert = options.upsert !== void 0 ? options.upsert : false;
        if (upsert) {
          const cursor = new Cursor(this, query);
          const docs = await cursor.limit(1)._execAsync();
          if (docs.length !== 1) {
            let toBeInserted;
            try {
              model.checkObject(update);
              toBeInserted = update;
            } catch (e) {
              toBeInserted = model.modify(model.deepCopy(query, true), update);
            }
            const newDoc = await this._insertAsync(toBeInserted);
            return { numAffected: 1, affectedDocuments: newDoc, upsert: true };
          }
        }
        let numReplaced = 0;
        let modifiedDoc;
        const modifications = [];
        let createdAt;
        const candidates = await this._getCandidatesAsync(query);
        for (const candidate of candidates) {
          if (model.match(candidate, query) && (multi || numReplaced === 0)) {
            numReplaced += 1;
            if (this.timestampData) {
              createdAt = candidate.createdAt;
            }
            modifiedDoc = model.modify(candidate, update);
            if (this.timestampData) {
              modifiedDoc.createdAt = createdAt;
              modifiedDoc.updatedAt = /* @__PURE__ */ new Date();
            }
            modifications.push({ oldDoc: candidate, newDoc: modifiedDoc });
          }
        }
        this._updateIndexes(modifications);
        const updatedDocs = modifications.map((x) => x.newDoc);
        await this.persistence.persistNewStateAsync(updatedDocs);
        if (!options.returnUpdatedDocs)
          return { numAffected: numReplaced, upsert: false, affectedDocuments: null };
        else {
          let updatedDocsDC = [];
          updatedDocs.forEach((doc) => {
            updatedDocsDC.push(model.deepCopy(doc));
          });
          if (!multi)
            updatedDocsDC = updatedDocsDC[0];
          return { numAffected: numReplaced, affectedDocuments: updatedDocsDC, upsert: false };
        }
      }
      /**
       * Callback version of {@link Datastore#updateAsync}.
       * @param {query} query
       * @param {document|*} update
       * @param {Object|Datastore~updateCallback} [options|]
       * @param {boolean} [options.multi = false]
       * @param {boolean} [options.upsert = false]
       * @param {boolean} [options.returnUpdatedDocs = false]
       * @param {Datastore~updateCallback} [callback]
       * @see Datastore#updateAsync
       *
       */
      update(query, update, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        const _callback = (err, res = {}) => {
          if (callback)
            callback(err, res.numAffected, res.affectedDocuments, res.upsert);
        };
        callbackify((query2, update2, options2) => this.updateAsync(query2, update2, options2))(query, update, options, _callback);
      }
      /**
       * Update all docs matching query.
       * @param {query} query is the same kind of finding query you use with `find` and `findOne`.
       * @param {document|*} update specifies how the documents should be modified. It is either a new document or a
       * set of modifiers (you cannot use both together, it doesn't make sense!). Using a new document will replace the
       * matched docs. Using a set of modifiers will create the fields they need to modify if they don't exist, and you can
       * apply them to subdocs. Available field modifiers are `$set` to change a field's value, `$unset` to delete a field,
       * `$inc` to increment a field's value and `$min`/`$max` to change field's value, only if provided value is
       * less/greater than current value. To work on arrays, you have `$push`, `$pop`, `$addToSet`, `$pull`, and the special
       * `$each` and `$slice`.
       * @param {Object} [options = {}] Optional options
       * @param {boolean} [options.multi = false] If true, can update multiple documents
       * @param {boolean} [options.upsert = false] If true, can insert a new document corresponding to the `update` rules if
       * your `query` doesn't match anything. If your `update` is a simple object with no modifiers, it is the inserted
       * document. In the other case, the `query` is stripped from all operator recursively, and the `update` is applied to
       * it.
       * @param {boolean} [options.returnUpdatedDocs = false] (not Mongo-DB compatible) If true and update is not an upsert,
       * will return the array of documents matched by the find query and updated. Updated documents will be returned even
       * if the update did not actually modify them.
       * @return {Promise<{numAffected: number, affectedDocuments: document[]|document|null, upsert: boolean}>}
       * - `upsert` is `true` if and only if the update did insert a document, **cannot be true if `options.upsert !== true`**.
       * - `numAffected` is the number of documents affected by the update or insertion (if `options.multi` is `false` or `options.upsert` is `true`, cannot exceed `1`);
       * - `affectedDocuments` can be one of the following:
       *    - If `upsert` is `true`, the inserted document;
       *    - If `options.returnUpdatedDocs` is `false`, `null`;
       *    - If `options.returnUpdatedDocs` is `true`:
       *      - If `options.multi` is `false`, the updated document;
       *      - If `options.multi` is `true`, the array of updated documents.
       * @async
       */
      updateAsync(query, update, options = {}) {
        return this.executor.pushAsync(() => this._updateAsync(query, update, options));
      }
      /**
       * @callback Datastore~removeCallback
       * @param {?Error} err
       * @param {?number} numRemoved
       */
      /**
       * Internal version without using the {@link Datastore#executor} of {@link Datastore#removeAsync}, use it instead.
       *
       * @param {query} query
       * @param {object} [options]
       * @param {boolean} [options.multi = false]
       * @return {Promise<number>}
       * @private
       * @see Datastore#removeAsync
       */
      async _removeAsync(query, options = {}) {
        const multi = options.multi !== void 0 ? options.multi : false;
        const candidates = await this._getCandidatesAsync(query, true);
        const removedDocs = [];
        let numRemoved = 0;
        candidates.forEach((d) => {
          if (model.match(d, query) && (multi || numRemoved === 0)) {
            numRemoved += 1;
            removedDocs.push({ $$deleted: true, _id: d._id });
            this._removeFromIndexes(d);
          }
        });
        await this.persistence.persistNewStateAsync(removedDocs);
        return numRemoved;
      }
      /**
       * Callback version of {@link Datastore#removeAsync}.
       * @param {query} query
       * @param {object|Datastore~removeCallback} [options={}]
       * @param {boolean} [options.multi = false]
       * @param {Datastore~removeCallback} [cb = () => {}]
       * @see Datastore#removeAsync
       */
      remove(query, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        const callback = cb || (() => {
        });
        callbackify((query2, options2) => this.removeAsync(query2, options2))(query, options, callback);
      }
      /**
       * Remove all docs matching the query.
       * @param {query} query MongoDB-style query
       * @param {object} [options={}] Optional options
       * @param {boolean} [options.multi = false] If true, can update multiple documents
       * @return {Promise<number>} How many documents were removed
       * @async
       */
      removeAsync(query, options = {}) {
        return this.executor.pushAsync(() => this._removeAsync(query, options));
      }
    };
    module.exports = Datastore;
  }
});

// node_modules/@seald-io/nedb/index.js
var require_nedb = __commonJS({
  "node_modules/@seald-io/nedb/index.js"(exports, module) {
    var Datastore = require_datastore();
    module.exports = Datastore;
  }
});

// node_modules/nedb-promises/src/Cursor.js
var require_Cursor = __commonJS({
  "node_modules/nedb-promises/src/Cursor.js"(exports, module) {
    var OriginalCursor = require_cursor();
    var Cursor = class {
      constructor(datastore, op, ...args) {
        const cursor = datastore.__original[op](...args);
        if (!(cursor instanceof OriginalCursor)) {
          throw new TypeError(`Unexpected ${typeof original}, expected: Cursor (nedb/lib/cursor)`);
        }
        Object.defineProperties(this, {
          __original: {
            configurable: false,
            enumerable: false,
            writable: false,
            value: cursor
          },
          __datastore: {
            configurable: false,
            enumerable: false,
            writable: false,
            value: datastore
          },
          __op: {
            configurable: false,
            enumerable: false,
            writable: false,
            value: op
          },
          __args: {
            configurable: false,
            enumerable: false,
            writable: false,
            value: args
          }
        });
      }
      /**
       * Sort the queried documents.
       *
       * See: https://github.com/louischatriot/nedb#sorting-and-paginating
       * 
       * @return {Cursor}
       */
      sort(...args) {
        this.__original.sort(...args);
        return this;
      }
      /**
       * Skip some of the queried documents.
       *
       * See: https://github.com/louischatriot/nedb#sorting-and-paginating
       * 
       * @return {Cursor}
       */
      skip(...args) {
        this.__original.skip(...args);
        return this;
      }
      /**
       * Limit the queried documents.
       *
       * See: https://github.com/louischatriot/nedb#sorting-and-paginating
       * 
       * @return {Cursor}
       */
      limit(...args) {
        this.__original.limit(...args);
        return this;
      }
      /**
       * Set the document projection.
       * 
       * See: https://github.com/louischatriot/nedb#projections
       * 
       * @return {Cursor}
       */
      project(...args) {
        this.__original.projection(...args);
        return this;
      }
      /**
       * Execute the cursor.
       *
       * Since the Cursor has a `then` and a `catch` method
       * JavaScript identifies it as a thenable object
       * thus you can await it in async functions.
       *
       * @example
       * // in an async function
       * await datastore.find(...)
       *  .sort(...)
       *  .limit(...)
       *
       * @example
       * // the previous is the same as:
       * await datastore.find(...)
       *  .sort(...)
       *  .limit(...)
       *  .exec()
       * 
       * @return {Promise<Object[]>}
       */
      async exec() {
        await this.__datastore.load();
        try {
          const result = await this.__original.execAsync();
          this.__datastore.broadcastSuccess(this.__op, result, ...this.__args);
          return result;
        } catch (error) {
          this.__datastore.broadcastError(this.__op, error, ...this.__args);
          throw error;
        }
      }
      /**
       * Execute the cursor and set promise callbacks.
       * 
       * For more information visit:
       * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then
       * 
       * @param  {Function} fulfilled
       * @param  {Function} [rejected]
       * @return {Promise}
       */
      then(fulfilled, rejected) {
        return this.exec().then(fulfilled, rejected);
      }
      /**
       * Execute the cursor and set promise error callback.
       *
       * For more information visit:
       * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch
       * 
       * @param  {Function} rejected
       * @return {Promise}
       */
      catch(rejected) {
        return this.exec().catch(rejected);
      }
    };
    module.exports = Cursor;
  }
});

// node_modules/nedb-promises/src/Datastore.js
var require_Datastore = __commonJS({
  "node_modules/nedb-promises/src/Datastore.js"(exports, module) {
    var EventEmitter = require_events();
    var OriginalDatastore = require_nedb();
    var Cursor = require_Cursor();
    var Datastore = class extends EventEmitter {
      /**
       * Create a database instance.
       *
       * Use this over `new Datastore(...)` to access
       * original nedb datastore properties, such as
       * `datastore.persistence`.
       *
       * Note that this method only creates the `Datastore`
       * class instance, not the datastore file itself.
       * The file will only be created once an operation
       * is issued against the datastore or if you call
       * the `load` instance method explicitly.
       * 
       * The path (if specified) will be relative to `process.cwd()`
       * (unless an absolute path was passed).
       *
       * For more information visit:
       * https://github.com/louischatriot/nedb#creatingloading-a-database
       * 
       * @param  {string|Object} [pathOrOptions]
       * @return {Proxy<static>}
       */
      static create(pathOrOptions) {
        return new Proxy(new this(pathOrOptions), {
          get(target, key) {
            return target[key] ? target[key] : target.__original[key];
          },
          set(target, key, value) {
            return Object.prototype.hasOwnProperty.call(target.__original, key) ? target.__original[key] = value : target[key] = value;
          }
        });
      }
      /**
       * Datastore constructor...
       *
       * You should use `Datastore.create(...)` instead
       * of `new Datastore(...)`. With that you can access
       * the original datastore's properties such as `datastore.persistence`.
       *
       * Create a Datastore instance.
       * 
       * Note that the datastore will be created
       * relative to `process.cwd()`
       * (unless an absolute path was passed).
       * 
       * It's basically the same as the original:
       * https://github.com/louischatriot/nedb#creatingloading-a-database
       * 
       * @param  {string|Object} [pathOrOptions]
       * @return {static}
       */
      constructor(pathOrOptions) {
        super();
        const datastore = new OriginalDatastore(
          typeof pathOrOptions === "string" ? { filename: pathOrOptions } : pathOrOptions
        );
        Object.defineProperties(this, {
          __loaded: {
            enumerable: false,
            writable: true,
            value: null
          },
          __original: {
            configurable: true,
            enumerable: false,
            writable: false,
            value: datastore
          }
        });
        this.__original.on("compaction.done", () => {
          this.emit("compactionDone", this);
        });
      }
      /**
       * Load the datastore.
       *
       * Note that you don't necessarily have to call
       * this method to load the datastore as it will
       * automatically be called and awaited on any
       * operation issued against the datastore
       * (i.e.: `find`, `findOne`, etc.).
       * 
       * @return {Promise<undefined>}
       */
      load() {
        if (!(this.__loaded instanceof Promise)) {
          this.__loaded = this.__original.loadDatabaseAsync().then(() => this.broadcastSuccess("load")).catch((error) => {
            this.broadcastError("load", error);
            throw error;
          });
        }
        return this.__loaded;
      }
      /**
       * Find documents that match the specified `query`.
       *
       * It's basically the same as the original:
       * https://github.com/louischatriot/nedb#finding-documents
       *
       * There are differences minor in how the cursor works though.
       *
       * @example
       * datastore.find({ ... }).sort({ ... }).exec().then(...)
       *
       * @example
       * datastore.find({ ... }).sort({ ... }).then(...)
       *
       * @example
       * // in an async function
       * await datastore.find({ ... }).sort({ ... })
       * 
       * @param  {Object} [query]
       * @param  {Object} [projection]
       * @return {Cursor}
       */
      find(query = {}, projection) {
        if (typeof projection === "function") {
          projection = {};
        }
        return new Cursor(this, "find", query, projection);
      }
      /**
       * Find a document that matches the specified `query`.
       *
       * It's basically the same as the original:
       * https://github.com/louischatriot/nedb#finding-documents
       *
       * @example
       * datastore.findOne({ ... }).then(...)
       *
       * @example
       * // in an async function
       * await datastore.findOne({ ... }).sort({ ... })
       * 
       * @param  {Object} [query]
       * @param  {Object} [projection]
       * @return {Cursor}
       */
      findOne(query = {}, projection) {
        if (typeof projection === "function") {
          projection = {};
        }
        return new Cursor(this, "findOne", query, projection);
      }
      /**
       * Insert a document or documents.
       *
       * It's basically the same as the original:
       * https://github.com/louischatriot/nedb#inserting-documents
       * 
       * @param  {Object|Object[]} docs
       * @return {Promise<Object|Object[]>}
       */
      async insert(docs) {
        await this.load();
        try {
          const result = await this.__original.insertAsync(docs);
          this.broadcastSuccess("insert", docs);
          return result;
        } catch (error) {
          this.broadcastError("insert", error, docs);
          throw error;
        }
      }
      /**
       * Insert a single document.
       *
       * This is just an alias for `insert` with object destructuring
       * to ensure a single document.
       * 
       * @param  {Object} doc
       * @return {Promise<Object>}
       */
      insertOne({ ...doc }) {
        return this.insert(doc);
      }
      /**
       * Insert multiple documents.
       *
       * This is just an alias for `insert` with array destructuring
       * to ensure multiple documents.
       * 
       * @param  {Object[]} docs
       * @return {Promise<Object[]>}
       */
      insertMany([...docs]) {
        return this.insert(docs);
      }
      /**
       * Update documents that match the specified `query`.
       *
       * It's basically the same as the original:
       * https://github.com/louischatriot/nedb#updating-documents
       *
       * If you set `options.returnUpdatedDocs`,
       * the returned promise will resolve with
       * an object (if `options.multi` is `false`) or
       * with an array of objects.
       * 
       * @param  {Object} query
       * @param  {Object} update
       * @param  {Object} [options]
       * @return {Promise<number|Object|Object[]>}
       */
      async update(query, update, options = {}) {
        await this.load();
        try {
          const { numAffected, affectedDocuments } = await this.__original.updateAsync(query, update, options);
          const result = options.returnUpdatedDocs ? affectedDocuments : numAffected;
          this.broadcastSuccess("update", result, query, update, options);
          return result;
        } catch (error) {
          this.broadcastError("update", error, query, update, options);
          throw error;
        }
      }
      /**
       * Update a single document that matches the specified `query`.
       *
       * This is just an alias for `update` with `options.multi` set to `false`.
       * 
       * @param  {Object} query
       * @param  {Object} update
       * @param  {Object} [options]
       * 
       * @return {Promise<number|Object>}
       */
      updateOne(query, update, options = {}) {
        return this.update(query, update, { ...options, multi: false });
      }
      /**
       * Update multiple documents that match the specified `query`.
       *
       * This is just an alias for `update` with `options.multi` set to `true`.
       *
       * @param  {Object} query
       * @param  {Object} update
       * @param  {Object} [options]
       * 
       * @return {Promise<number|Object[]>}
       */
      updateMany(query, update, options = {}) {
        return this.update(query, update, { ...options, multi: true });
      }
      /**
       * Remove documents that match the specified `query`.
       *
       * It's basically the same as the original:
       * https://github.com/louischatriot/nedb#removing-documents
       * 
       * @param  {Object} [query]
       * @param  {Object} [options]
       * @return {Promise<number>}
       */
      async remove(query = {}, options = {}) {
        await this.load();
        try {
          const result = await this.__original.removeAsync(query, options);
          this.broadcastSuccess("remove", result, query, options);
          return result;
        } catch (error) {
          this.broadcastError("remove", error, query, options);
          throw error;
        }
      }
      /**
       * Remove the first document that matches the specified `query`.
       *
       * This is just an alias for `remove` with `options.multi` set to `false`.
       * 
       * @param  {Object} [query]
       * @param  {Object} [options]
       * 
       * @return {Promise<number>}
       */
      removeOne(query, options = {}) {
        return this.remove(query, { ...options, multi: false });
      }
      /**
       * Remove all documents that match the specified `query`.
       *
       * This is just an alias for `remove` with `options.multi` set to `true`.
       * 
       * @param  {Object} [query]
       * @param  {Object} [options]
       * 
       * @return {Promise<number>}
       */
      removeMany(query, options = {}) {
        return this.remove(query, { ...options, multi: true });
      }
      /**
       * Remove the first document that matches the specified `query`.
       *
       * This is just an alias for `removeOne`.
       * 
       * @param  {Object} [query]
       * @param  {Object} [options]
       * 
       * @return {Promise<number>}
       */
      deleteOne(query, options) {
        return this.removeOne(query, options);
      }
      /**
       * Remove all documents that match the specified `query`.
       *
       * This is just an alias for `removeMany`.
       * 
       * @param  {Object} [query]
       * @param  {Object} [options]
       * 
       * @return {Promise<number>}
       */
      deleteMany(query, options) {
        return this.removeMany(query, options);
      }
      /**
       * Count documents matching the specified `query`.
       *
       * It's basically the same as the original:
       * https://github.com/louischatriot/nedb#counting-documents
       *
       * @example
       * datastore.count({ ... }).limit(...).then(...)
       *
       * @example
       * // in an async function
       * await datastore.count({ ... })
       * // or
       * await datastore.count({ ... }).sort(...).limit(...)
       * 
       * @param  {Object} [query]
       * @return {Cursor}
       */
      count(query = {}) {
        return new Cursor(this, "count", query);
      }
      /**
       * https://github.com/louischatriot/nedb#indexing
       * 
       * @param  {Object} options
       * @return {Promise<undefined>}
       */
      async ensureIndex(options) {
        try {
          const result = await this.__original.ensureIndexAsync(options);
          this.broadcastSuccess("ensureIndex", result, options);
          return result;
        } catch (error) {
          this.broadcastError("ensureIndex", error, options);
          throw error;
        }
      }
      /**
       * https://github.com/louischatriot/nedb#indexing
       * 
       * @param  {string} field
       * @return {Promise<undefined>}
       */
      async removeIndex(field) {
        try {
          const result = await this.__original.removeIndexAsync(field);
          this.broadcastSuccess("removeIndex", result, field);
          return result;
        } catch (error) {
          this.broadcastError("removeIndex", error, field);
          throw error;
        }
      }
      /**
       * Broadcasts operation success messages.
       * 
       * @param  {string} op
       * @param  {*}      result
       * @param  {...*}   args
       * 
       * @return {undefined}
       * @private
       */
      broadcastSuccess(op, result, ...args) {
        this.emit(op, this, result, ...args);
        return this;
      }
      /**
       * Broadcasts operation error messages.
       * 
       * @param  {string} op
       * @param  {Error}  error
       * @param  {...*}   args
       * 
       * @return {undefined}
       * @private
       */
      broadcastError(op, error, ...args) {
        this.emit(`${op}Error`, this, error, ...args);
        this.emit("__error__", this, op, error, ...args);
        return this;
      }
    };
    module.exports = Datastore;
  }
});

// node_modules/nedb-promises/index.js
var require_nedb_promises = __commonJS({
  "node_modules/nedb-promises/index.js"(exports, module) {
    module.exports = require_Datastore();
  }
});
export default require_nedb_promises();
/*! Bundled license information:

localforage/dist/localforage.js:
  (*!
      localForage -- Offline Storage, Improved
      Version 1.10.0
      https://localforage.github.io/localForage
      (c) 2013-2017 Mozilla, Apache License 2.0
  *)
*/
//# sourceMappingURL=nedb-promises.js.map
